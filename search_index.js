var documenterSearchIndex = {"docs":
[{"location":"internals/space/#Spaces","page":"Spaces","title":"Spaces","text":"","category":"section"},{"location":"internals/space/#Bramble.GridSpaceBuffer","page":"Spaces","title":"Bramble.GridSpaceBuffer","text":"struct GridSpaceBuffer{BT, VT, T}\n\nManages a pool of reusable VectorBuffers for a specific grid size and backend.\n\nThis structure is the core of the buffer management system. It holds an OrderedDict of VectorBuffers, allowing temporary vectors to be efficiently reused, thus minimizing memory allocation during iterative computations.\n\nFields\n\nbuffer: an OrderedDict mapping an integer key to each VectorBuffer in the pool.\nbackend: the computational backend associated with the buffers.\nnpts: the size (npts) of the vectors managed by this buffer pool.\n\n\n\n\n\n","category":"type"},{"location":"internals/space/#Bramble.VectorBuffer","page":"Spaces","title":"Bramble.VectorBuffer","text":"mutable struct VectorBuffer{T, VT<:AbstractArray{T, 1}} <: AbstractArray{T, 1}\n\nA simple, mutable wrapper around a vector, designed to be part of a buffer pool to avoid repeated memory allocations during iterative computations.\n\nThe in_use flag acts as a simple locking mechanism to track whether the buffer's data is currently being used in a computation.\n\nFields\n\nvector: the underlying vector that holds the data.\nin_use: a boolean flag indicating if the buffer is currently locked (in use).\n\n\n\n\n\n","category":"type"},{"location":"internals/space/#Bramble.add_buffer!-Tuple{Bramble.GridSpaceBuffer}","page":"Spaces","title":"Bramble.add_buffer!","text":"add_buffer!(space_buffer::GridSpaceBuffer)\n\nDynamically adds one new, available VectorBuffer to the pool. This is called when a request is made for a buffer but all existing ones are in use.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Bramble.in_use-Tuple{Bramble.VectorBuffer}","page":"Spaces","title":"Bramble.in_use","text":"in_use(buffer::VectorBuffer)\n\nChecks if the VectorBuffer is currently marked as in use (locked).\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Bramble.lock!-Tuple{Bramble.GridSpaceBuffer, Any}","page":"Spaces","title":"Bramble.lock!","text":"lock!(space_buffer::GridSpaceBuffer, i)\n\nLocks the i-th buffer in the pool and returns the underlying vector for immediate use.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Bramble.lock!-Tuple{Bramble.VectorBuffer}","page":"Spaces","title":"Bramble.lock!","text":"lock!(buffer::VectorBuffer)\n\nMarks the VectorBuffer as currently in use (locks it).\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Bramble.nbuffers-Tuple{Bramble.GridSpaceBuffer}","page":"Spaces","title":"Bramble.nbuffers","text":"nbuffers(space_buffer::GridSpaceBuffer)\n\nReturns the total number of buffers (both locked and unlocked) currently in the pool.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Bramble.simple_space_buffer-Tuple{Bramble.Backend, Int64}","page":"Spaces","title":"Bramble.simple_space_buffer","text":"simple_space_buffer(b::Backend, npts::Int; nbuffers::Int = 0)\n\nCreates a GridSpaceBuffer pool, optionally pre-allocating a number of buffers. \"Warming up\" the pool by pre-allocating buffers can improve performance on the first few iterations.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Bramble.unlock!-Tuple{Bramble.GridSpaceBuffer, Any}","page":"Spaces","title":"Bramble.unlock!","text":"unlock!(space_buffer::GridSpaceBuffer, i)\n\nUnlocks the i-th buffer in the pool, marking it as available for reuse.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Bramble.unlock!-Tuple{Bramble.VectorBuffer}","page":"Spaces","title":"Bramble.unlock!","text":"unlock!(buffer::VectorBuffer)\n\nMarks the VectorBuffer as available (unlocks it).\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Bramble.vector-Tuple{Bramble.VectorBuffer}","page":"Spaces","title":"Bramble.vector","text":"vector(buffer::VectorBuffer)\n\nReturns the underlying vector stored in the VectorBuffer.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Bramble.vector_buffer-Tuple{Bramble.Backend, Int64}","page":"Spaces","title":"Bramble.vector_buffer","text":"vector_buffer(b::Backend, n::Int)\n\nCreates a single VectorBuffer of size n, associated with a computational backend b. The buffer is initialized as unlocked (in_use = false).\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Bramble.vector_buffer-Tuple{Bramble.GridSpaceBuffer}","page":"Spaces","title":"Bramble.vector_buffer","text":"vector_buffer(space_buffer::GridSpaceBuffer)\n\nRetrieves an available vector from the buffer pool.\n\nThis is the main function for acquiring a temporary vector. It first searches for any unlocked buffer. If all existing buffers are locked, it transparently allocates a new one and adds it to the pool. The function returns the vector itself and its integer key, which must be used later to unlock! it. The buffer is marked as locked upon retrieval.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Bramble.AbstractSpaceType","page":"Spaces","title":"Bramble.AbstractSpaceType","text":"AbstractSpaceType{N}\n\nAbstract supertype for all function spaces defined on a mesh.\n\nThis is the top-level abstraction for a grid-based function space. The parameter N represents the number of components of the field (e.g., N=1 for a scalar field, N=3 for a 3D vector field).\n\n\n\n\n\n","category":"type"},{"location":"internals/space/#Bramble.MatrixElement","page":"Spaces","title":"Bramble.MatrixElement","text":"struct MatrixElement{S, T, MT<:AbstractArray{T, 2}} <: AbstractArray{T, 2}\n\nRepresents a discrete linear operator (a matrix) that acts on a function space.\n\nSimilar to , this container bundles a raw matrix (data) with its parent space. This is used to represent discretization matrices from methods like finite differences (e.g., a differentiation or averaging matrix). Subtyping AbstractMatrix allows it to be used like a standard Julia matrix.\n\nFields\n\ndata: the matrix data representing the linear operator.\nspace: the parent function space to which this vector belongs.\n\n\n\n\n\n","category":"type"},{"location":"internals/space/#Bramble.VectorElement","page":"Spaces","title":"Bramble.VectorElement","text":"struct VectorElement{S, T, VT<:AbstractArray{T, 1}} <: AbstractArray{T, 1}\n\nRepresents a grid function (a vector) that belongs to a specific function space.\n\nThis is a wrapper that bundles the raw numerical data (the vector data) with its parent space. The space provides the essential context, such as the underlying mesh and associated operators. By subtyping AbstractVector, a VectorElement can be used just like a regular Julia vector in most operations.\n\nFields\n\ndata: the raw vector data containing the degrees of freedom.\nspace: the parent function space to which this vector belongs.\n\n\n\n\n\n","category":"type"},{"location":"internals/space/#Base.eltype-Tuple{Bramble.AbstractSpaceType}","page":"Spaces","title":"Base.eltype","text":"eltype(Wₕ::AbstractSpaceType)\n\nReturns the element type (e.g., Float64) of the data in the function space Wₕ. It also works if the argument is the type of the space.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Bramble.average_matrix-Tuple{Bramble.AbstractSpaceType, Any}","page":"Spaces","title":"Bramble.average_matrix","text":"average_matrix(Wₕ::AbstractSpaceType, i)\n\nReturns the averaging matrix for the i-th dimension of the space Wₕ.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Bramble.backend-Tuple{Bramble.AbstractSpaceType}","page":"Spaces","title":"Bramble.backend","text":"backend(Wₕ::Bramble.AbstractSpaceType) -> Any\n\n\nReturns the computational backend associated with the space Wₕ.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Bramble.backward_difference_matrix-Tuple{Bramble.AbstractSpaceType, Any}","page":"Spaces","title":"Bramble.backward_difference_matrix","text":"backward_difference_matrix(Wₕ::AbstractSpaceType, i)\n\nReturns the backward difference matrix for the i-th dimension of the space Wₕ.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Bramble.has_average_matrix-Tuple{Bramble.AbstractSpaceType}","page":"Spaces","title":"Bramble.has_average_matrix","text":"has_average_matrix(Wₕ::AbstractSpaceType)\n\nChecks if the averaging matrices have been computed and stored for Wₕ.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Bramble.has_backward_difference_matrix-Tuple{Bramble.AbstractSpaceType}","page":"Spaces","title":"Bramble.has_backward_difference_matrix","text":"has_backward_difference_matrix(Wₕ::AbstractSpaceType)\n\nChecks if the backward difference matrices have been computed and stored for Wₕ.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Bramble.mesh_type-Tuple{Bramble.AbstractSpaceType}","page":"Spaces","title":"Bramble.mesh_type","text":"mesh_type(Wₕ::AbstractSpaceType)\n\nReturns the type of the mesh associated with the function space Wₕ. Also works if the argument is the type of the space.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Bramble.space-Tuple{Bramble.AbstractSpaceType}","page":"Spaces","title":"Bramble.space","text":"space(Wₕ::AbstractSpaceType)\n\nReturns the function space Wₕ itself.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Bramble.vector_buffer-Tuple{Bramble.AbstractSpaceType}","page":"Spaces","title":"Bramble.vector_buffer","text":"vector_buffer(Wₕ::AbstractSpaceType)\n\nReturns the GridSpaceBuffer used for efficient memory management in the space Wₕ.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Bramble.ScalarGridSpace","page":"Spaces","title":"Bramble.ScalarGridSpace","text":"struct ScalarGridSpace{D, T, VT<:AbstractArray{T, 1}, MT<:AbstractArray{T, 2}, MType<:Bramble.AbstractMeshType{D}, BT<:Bramble.Backend{VT<:AbstractArray{T, 1}, MT<:AbstractArray{T, 2}}} <: Bramble.AbstractSpaceType{1}\n\nRepresents a function space for scalar fields defined on a mesh.\n\nThis structure is a cornerstone for numerical simulations, bundling a mesh with pre-computed weights for discrete inner products, lazy-initialized matrices for finite difference operators (like differentiation and averaging), and an efficient memory buffer for temporary vectors.\n\nFields\n\nmesh: the underlying mesh of the grid space.\nweights: a SpaceWeights object holding vectors for various discrete inner products.\nbackward_difference_matrix: a tuple of matrices for the backward difference operator in each dimension.\nhas_backward_difference_matrix: a flag indicating if the difference matrices have been computed and stored.\naverage_matrix: a tuple of matrices for the averaging operator in each dimension.\nhas_average_matrix: a flag indicating if the averaging matrices have been computed and stored.\nvector_buffer: a GridSpaceBuffer for efficient reuse of temporary vectors, minimizing memory allocations.\n\nDiscrete Inner Products\n\nThe weights object stores vectors for different discrete L^2 inner products on the space of grid functions. They are defined as follows:\n\n- :innerₕ: The standard discrete L^2 inner product, weighted by the cell measure square_k.\n\n1D case:\n\n(u_h v_h)_h = sum_i=1^N_x square_i u_h(x_i) v_h(x_i)\n\n2D case:\n\n(u_h v_h)_h = sum_i=1^N_xsum_j=1^N_y square_ij u_h(x_iy_j) v_h(x_iy_j)\n\n3D case:\n\n(u_h v_h)_h = sum_i=1^N_xsum_j=1^N_ysum_l=1^N_z square_ijl u_h(x_iy_jz_l) v_h(x_iy_jz_l)\n\nHere, cdot denotes the measure of the set (length, area, or volume). See cell_measure for details.\n\n- :inner₊, :inner₊ₓ, :inner₊ᵧ, :inner₊₂: Modified discrete L^2 inner products, weighted by a mix of forward/backward spacings (h_k) and cell widths (h_k+12).\n\n1D case (:inner₊):\n\n(u_h v_h)_+ = sum_i=1^N_x h_i u_h(x_i) v_h(x_i)\n\n2D case (:inner₊ₓ, :inner₊ᵧ):\n\n(u_h v_h)_+x = sum_i=1^N_xsum_j=1^N_y h_xi h_yj+12 u_h(x_iy_j) v_h(x_iy_j)\n\n(u_h v_h)_+y = sum_i=1^N_xsum_j=1^N_y h_xi+12 h_yj u_h(x_iy_j) v_h(x_iy_j)\n\n3D case (:inner₊ₓ, :inner₊ᵧ, :inner₊₂):\n\n(u_h v_h)_+x = sum_i=1^N_xsum_j=1^N_ysum_l=1^N_z h_xi h_yj+12 h_zl+12 u_h(x_iy_jz_l) v_h(x_iy_jz_l)\n\n(u_h v_h)_+y = sum_i=1^N_xsum_j=1^N_ysum_l=1^N_z h_xi+12 h_yj h_zl+12 u_h(x_iy_jz_l) v_h(x_iy_jz_l)\n\n(u_h v_h)_+z = sum_i=1^N_xsum_j=1^N_ysum_l=1^N_z h_xi+12 h_yj+12 h_zl u_h(x_iy_jz_l) v_h(x_iy_jz_l)\n\n\n\n\n\n","category":"type"},{"location":"internals/space/#Bramble.SpaceWeights","page":"Spaces","title":"Bramble.SpaceWeights","text":"struct SpaceWeights{D, VT<:(AbstractVector)}\n\nA container that stores pre-computed weight vectors for various discrete inner products on a grid space.\n\nThis struct holds the diagonal elements (weights) needed to compute different types of inner products, such as those weighted by cell measures or staggered grid spacings. By pre-computing and storing these vectors, numerical simulations can avoid costly recalculations within iterative loops.\n\nFields\n\ninnerh: weight vector for the standard discrete L^2 inner product (:innerₕ), based on cell measures (square_k).\ninnerplus: a tuple of weight vectors for modified, staggered inner products (:inner₊ₓ, :inner₊ᵧ, etc.), with one vector for each spatial dimension.\n\nFor a detailed explanation of the mathematical formulas corresponding to these weights, please refer to the documentation for ScalarGridSpace.\n\n\n\n\n\n","category":"type"},{"location":"internals/space/#Bramble.__innerplus_weights!-Tuple{Any, Any}","page":"Spaces","title":"Bramble.__innerplus_weights!","text":"__innerplus_weights!(v, innerplus_per_component)\n\nBuilds the weights for the modified discrete L^2 inner product on the space of grid functions ScalarGridSpace. The result is stored in vector v.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Bramble._innerh_weights!-Tuple{Any, Bramble.AbstractMeshType}","page":"Spaces","title":"Bramble._innerh_weights!","text":"_innerh_weights!(u, Ωₕ::AbstractMeshType)\n\nBuilds the weights for the standard discrete L^2 inner product, inner_h(cdot cdot), on the space of grid functions, following the order of the points provided by indices(Ωₕ). The values are stored in vector u.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Bramble._innerplus_mean_weights!-Union{Tuple{VT}, Tuple{VT, Any}, Tuple{VT, Any, Int64}} where VT","page":"Spaces","title":"Bramble._innerplus_mean_weights!","text":"_innerplus_mean_weights!(u::VT, Ωₕ, component::Int = 1) where VT\n\nBuilds a set of weights based on the half spacings, associated with the component-th direction, for the modified discrete L^2 inner product on the space of grid functions, following the order of the points. The values are stored in vector u. for each component.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Bramble._innerplus_weights!-Union{Tuple{VT}, Tuple{VT, Any}, Tuple{VT, Any, Any}} where VT","page":"Spaces","title":"Bramble._innerplus_weights!","text":"_innerplus_weights!(u::VT, Ωₕ, component = 1) where VT\n\nBuilds a set of weights based on the spacings, associated with the component-th direction, for the modified discrete L^2 inner product on the space of grid functions, following the order of the points provided by indices(Ωₕ). The values are stored in vector u.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Bramble.weights-Tuple{Bramble.ScalarGridSpace}","page":"Spaces","title":"Bramble.weights","text":"weights(Wₕ::ScalarGridSpace, [::InnerProductType], [i])\n\nReturns the weights associated with the functionspace. A second argument can be supplied detailing the type of weights.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Bramble.CompositeGridSpace","page":"Spaces","title":"Bramble.CompositeGridSpace","text":"mutable struct CompositeGridSpace{N, Spaces<:NTuple{N, Bramble.AbstractSpaceType}} <: Bramble.AbstractSpaceType{N}\n\nA CompositeGridSpace represents a grid space that is formed by composing N individual sub-spaces.\n\nFields\n\nspaces\n\n\n\n\n\n","category":"type"},{"location":"internals/space/#Bramble.PointwiseEvaluator","page":"Spaces","title":"Bramble.PointwiseEvaluator","text":"struct PointwiseEvaluator{F, M}\n\nHelper struct to bundle a function with its mesh. This allows passing both as a single callable object, pe(idx), which evaluates the function at the physical coordinates corresponding to the grid index idx.\n\nFields\n\nfunc\nmesh\n\n\n\n\n\n","category":"type"},{"location":"internals/space/#Bramble.__integrand1d-Tuple{Any, Any, Any}","page":"Spaces","title":"Bramble.__integrand1d","text":"__integrand1d(y, t, p)\n\nImplements the integrand function needed in the calculation of the averaging operator avgₕ. In this function, y denotes the return values, t denotes the integration variable and p denotes the parameters (integrand function f, points x, spacing h and indices idxs).\n\nFor efficiency, each integral in avgₕ is rewritten as an integral over [0,1] following\n\nint_a^b f(x) dx = (b-a) int_0^1 f(a + t (b-a)) dt\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Bramble.__integrandnd-Tuple{Any, Any, Any}","page":"Spaces","title":"Bramble.__integrandnd","text":"__integrandnd(y, t, p)\n\nImplements the integrand function needed in the calculation of avgₕ. In this function, y denotes the return values, t denotes the integration variable and p denotes the parameters (integrand function f, points x, measures meas and indices idxs).\n\nFor efficiency, each integral is calculated on 01^D, where D is the dimension of the integration domain. This is done through a similar change of variable as in __integrand1d(y, t, p).\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Bramble.space-Tuple{Bramble.VectorElement}","page":"Spaces","title":"Bramble.space","text":"space(uₕ::VectorElement)\n\nReturns the grid space associated with VectorElement uₕ.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Bramble.to_matrix-Union{Tuple{Bramble.VectorElement{ST, T} where T}, Tuple{ST}} where ST","page":"Spaces","title":"Bramble.to_matrix","text":"to_matrix(uₕ::VectorElement, [::ComponentStyle])\n\nReshapes the flat coefficient vector of uₕ into a multidimensional array that matches the logical layout of the grid points.\n\nFor a SingleComponent space, this returns a D-dimensional array.\nFor a MultiComponent space, it returns a tuple of D arrays, one for each component.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Bramble.values!-Tuple{Bramble.VectorElement, Any}","page":"Spaces","title":"Bramble.values!","text":"values!(uₕ::VectorElement, s)\n\nCopies the values of s into the coefficients of VectorElement uₕ.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Bramble.values-Tuple{Bramble.VectorElement}","page":"Spaces","title":"Bramble.values","text":"values(uₕ::VectorElement)\n\nReturns the coefficients of the VectorElement uₕ.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Base.:*-Tuple{Bramble.MatrixElement, Bramble.MatrixElement}","page":"Spaces","title":"Base.:*","text":"*(Uₕ::MatrixElement, Vₕ::MatrixElement)\n\nReturns a new MatrixElement given by multiplying the matrix of MatrixElement Uₕ by the matrix of MatrixElement Vₕ.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Base.:*-Tuple{Bramble.MatrixElement, Bramble.VectorElement}","page":"Spaces","title":"Base.:*","text":"Base.:*(Uₕ::MatrixElement, vₕ::VectorElement)\n\nReturns a new MatrixElement calculated by multiplying each coefficient of VectorElement vₕ with the corresponding column of Uₕ.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Base.:*-Tuple{Bramble.MatrixElement, Number}","page":"Spaces","title":"Base.:*","text":"*(Uₕ::MatrixElement, α::Number)\n\nReturns a new MatrixElement with coefficients given by the elementwise evaluation of Uₕ * α.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Base.:*-Tuple{Bramble.VectorElement, Bramble.MatrixElement}","page":"Spaces","title":"Base.:*","text":"Base.:*(uₕ::VectorElement, Vₕ::MatrixElement)\n\nReturns a new MatrixElement calculated by multiplying each coefficient of VectorElement uₕ with the corresponding row of Vₕ.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Base.:*-Tuple{Number, Bramble.MatrixElement}","page":"Spaces","title":"Base.:*","text":"*(α::Number, Uₕ::MatrixElement)\n\nReturns a new MatrixElement with coefficients given by the elementwise evaluation of α * Uₕ.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Base.:+-Tuple{Bramble.MatrixElement, Bramble.MatrixElement}","page":"Spaces","title":"Base.:+","text":"+(Uₕ::MatrixElement, Vₕ::MatrixElement)\n\nReturns a new MatrixElement given by adding the matrix of MatrixElement Uₕ to the matrix of MatrixElement Vₕ.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Base.:+-Tuple{Bramble.MatrixElement, Number}","page":"Spaces","title":"Base.:+","text":"+(Uₕ::MatrixElement, α::Number)\n\nReturns a new MatrixElement with coefficients given by the elementwise evaluation of Uₕ + α.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Base.:+-Tuple{Number, Bramble.MatrixElement}","page":"Spaces","title":"Base.:+","text":"+(α::Number, Uₕ::MatrixElement)\n\nReturns a new MatrixElement with coefficients given by the elementwise evaluation of α + Uₕ.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Base.:--Tuple{Bramble.MatrixElement, Bramble.MatrixElement}","page":"Spaces","title":"Base.:-","text":"-(Uₕ::MatrixElement, Vₕ::MatrixElement)\n\nReturns a new MatrixElement given by subtracting the matrix of MatrixElement Vₕ to the matrix of MatrixElement Uₕ.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Base.:--Tuple{Bramble.MatrixElement, Number}","page":"Spaces","title":"Base.:-","text":"-(Uₕ::MatrixElement, α::Number)\n\nReturns a new MatrixElement with coefficients given by the elementwise evaluation of Uₕ - α.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Base.:--Tuple{Number, Bramble.MatrixElement}","page":"Spaces","title":"Base.:-","text":"-(α::Number, Uₕ::MatrixElement)\n\nReturns a new MatrixElement with coefficients given by the elementwise evaluation of α - Uₕ.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Base.:/-Tuple{Bramble.MatrixElement, Number}","page":"Spaces","title":"Base.:/","text":"/(Uₕ::MatrixElement, α::Number)\n\nReturns a new MatrixElement with coefficients given by the elementwise evaluation of Uₕ / α.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Base.:/-Tuple{Number, Bramble.MatrixElement}","page":"Spaces","title":"Base.:/","text":"/(α::Number, Uₕ::MatrixElement)\n\nReturns a new MatrixElement with coefficients given by the elementwise evaluation of α / Uₕ.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Base.copyto!-Tuple{Bramble.MatrixElement, Bramble.MatrixElement}","page":"Spaces","title":"Base.copyto!","text":"Base.copyto!(Uₕ::MatrixElement, Vₕ::MatrixElement)\n\nCopies the coefficients of MatrixElement Vₕ into MatrixElement Uₕ.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Base.eltype-Union{Tuple{Bramble.MatrixElement{S, T, MT} where MT<:AbstractMatrix{T}}, Tuple{T}, Tuple{S}} where {S, T}","page":"Spaces","title":"Base.eltype","text":"eltype(Uₕ::MatrixElement{S,T})\n\nReturns the element type of a MatrixElement, T. CAn be applied to the type of the MatrixElement.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Base.similar-Union{Tuple{Bramble.MatrixElement{S, T, MT}}, Tuple{MT}, Tuple{T}, Tuple{S}} where {S, T, MT}","page":"Spaces","title":"Base.similar","text":"Base.similar(Uₕ::MatrixElement)\n\nReturns a similar MatrixElement to Uₕ.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Bramble.elements-Tuple{Bramble.AbstractSpaceType}","page":"Spaces","title":"Bramble.elements","text":"elements(Wₕ::AbstractSpaceType, [A::AbstractMatrix])\n\nReturns a MatrixElement from a given AbstractSpaceType, initialized with the identity matrix. If matrix A is provided, it is used instead.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Bramble.space-Tuple{Bramble.MatrixElement}","page":"Spaces","title":"Bramble.space","text":"space(Uₕ::MatrixElement)\n\nReturns the space associated with the MatrixElement Uₕ.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Bramble.shift-Union{Tuple{i}, Tuple{SHIFT_DIM}, Tuple{Bramble.AbstractMeshType, Val{SHIFT_DIM}, Val{i}}} where {SHIFT_DIM, i}","page":"Spaces","title":"Bramble.shift","text":"shift(Ωₕ, ::Val{SHIFT_DIM}, ::Val{i})\n\nCreates a shift operator on a D-dimensional mesh.\n\nSHIFT_DIM: The dimension along which to apply the shift (e.g., 1 for x, 2 for y).\ni: The shift amount (e.g., -1 for a backward shift).\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Bramble.backward_derivative_weights!-Tuple{AbstractVector, Bramble.AbstractMeshType, Val}","page":"Spaces","title":"Bramble.backward_derivative_weights!","text":"backward_derivative_weights!(v::AbstractVector, Ωₕ::AbstractMeshType, diff_dim::Val)\n\nComputes the geometric weights for the backward finite difference operator and stores them in-place in vector v.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Bramble.backward_difference-Tuple{Bramble.AbstractMeshType, Val}","page":"Spaces","title":"Bramble.backward_difference","text":"backward_difference(arg, dim_val::Val)\n\nConstructs the unscaled backward difference operator, representing the operation u_i - u_i-1.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Bramble.backward_difference_dim!-Union{Tuple{DIFF_DIM}, Tuple{D}, Tuple{Any, Any, Any, NTuple{D, Int64}, Val{DIFF_DIM}}} where {D, DIFF_DIM}","page":"Spaces","title":"Bramble.backward_difference_dim!","text":"backward_difference_dim!(out, in, [h], dims, diff_dim)\n\nLow-level, in-place function to compute the unscaled backward difference of vector in along dimension diff_dim, storing the result in out. This function computes u_i - u_i-1.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Bramble.backward_finite_difference-Tuple{Bramble.AbstractMeshType, Val}","page":"Spaces","title":"Bramble.backward_finite_difference","text":"backward_finite_difference(arg, dim_val::Val)\n\nConstructs the backward finite difference operator, which approximates the first derivative using the formula fracu_i - u_i-1h_i.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Bramble.forward_derivative_weights!-Tuple{AbstractVector, Bramble.AbstractMeshType, Val}","page":"Spaces","title":"Bramble.forward_derivative_weights!","text":"forward_derivative_weights!(v::AbstractVector, Ωₕ::AbstractMeshType, diff_dim::Val)\n\nComputes the geometric weights for the forward finite difference operator and stores them in-place in vector v.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Bramble.forward_difference-Tuple{Bramble.AbstractMeshType, Val}","page":"Spaces","title":"Bramble.forward_difference","text":"forward_difference(arg, dim_val::Val)\n\nConstructs the unscaled forward difference operator, representing the operation u_i+1 - u_i.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Bramble.forward_difference_dim!-Union{Tuple{DIFF_DIM}, Tuple{D}, Tuple{Any, Any, Any, NTuple{D, Int64}, Val{DIFF_DIM}}} where {D, DIFF_DIM}","page":"Spaces","title":"Bramble.forward_difference_dim!","text":"forward_difference_dim!(out, in, [h], dims, diff_dim)\n\nLow-level, in-place function to compute the unscaled forward difference of vector in along dimension diff_dim, storing the result in out. This function computes u_i+1 - u_i.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Bramble.forward_finite_difference-Tuple{Bramble.AbstractMeshType, Val}","page":"Spaces","title":"Bramble.forward_finite_difference","text":"forward_finite_difference(arg, dim_val::Val)\n\nConstructs the forward finite difference operator, which approximates the first derivative using the formula fracu_i+1 - u_ih_i.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Bramble.backward_jump-Tuple{Bramble.AbstractMeshType, Val}","page":"Spaces","title":"Bramble.backward_jump","text":"backward_jump(arg, dim_val::Val)\n\nConstructs or applies the backward jump operator, representing the operation u_i - u_i-1.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Bramble.backward_jump_dim!-Union{Tuple{DIFF_DIM}, Tuple{D}, Tuple{Any, Any, Any, NTuple{D, Int64}, Val{DIFF_DIM}}} where {D, DIFF_DIM}","page":"Spaces","title":"Bramble.backward_jump_dim!","text":"backward_jump_dim!(out, in, dims, jump_dim)\n\nLow-level, in-place function to compute the backward jump of vector in along dimension jump_dim, storing the result in out. This function computes u_i - u_i-1.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Bramble.forward_jump-Tuple{Bramble.AbstractMeshType, Val}","page":"Spaces","title":"Bramble.forward_jump","text":"forward_jump(arg, dim_val::Val)\n\nConstructs or applies the forward jump operator, representing the operation u_i+1 - u_i.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Bramble.forward_jump_dim!-Union{Tuple{DIFF_DIM}, Tuple{D}, Tuple{Any, Any, Any, NTuple{D, Int64}, Val{DIFF_DIM}}} where {D, DIFF_DIM}","page":"Spaces","title":"Bramble.forward_jump_dim!","text":"forward_jump_dim!(out, in, dims, jump_dim)\n\nLow-level, in-place function to compute the forward jump of vector in along dimension jump_dim, storing the result in out. This function computes u_i+1 - u_i.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Bramble.backward_average-Tuple{Bramble.AbstractMeshType, Val}","page":"Spaces","title":"Bramble.backward_average","text":"backward_average(arg, dim_val::Val)\n\nConstructs or applies the backward averaging operator, representing the operation fracu_i-1 + u_i2.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Bramble.backward_average_dim!-Union{Tuple{DIFF_DIM}, Tuple{D}, Tuple{Any, Any, Any, NTuple{D, Int64}, Val{DIFF_DIM}}} where {D, DIFF_DIM}","page":"Spaces","title":"Bramble.backward_average_dim!","text":"backward_average_dim!(out, in, dims, average_dim)\n\nLow-level, in-place function to compute the backward average of vector in along dimension average_dim, storing the result in out. This function computes fracu_i-1 + u_i2.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Bramble.forward_average-Tuple{Bramble.AbstractMeshType, Val}","page":"Spaces","title":"Bramble.forward_average","text":"forward_average(arg, dim_val::Val)\n\nConstructs or applies the forward averaging operator, representing the operation fracu_i + u_i+12.\n\n\n\n\n\n","category":"method"},{"location":"internals/space/#Bramble.forward_average_dim!-Union{Tuple{DIFF_DIM}, Tuple{D}, Tuple{Any, Any, Any, NTuple{D, Int64}, Val{DIFF_DIM}}} where {D, DIFF_DIM}","page":"Spaces","title":"Bramble.forward_average_dim!","text":"forward_average_dim!(out, in, dims, average_dim)\n\nLow-level, in-place function to compute the forward average of vector in along dimension average_dim, storing the result in out. This function computes fracu_i + u_i+12.\n\n\n\n\n\n","category":"method"},{"location":"internals/utils/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"internals/utils/#Backend","page":"Utilities","title":"Backend","text":"","category":"section"},{"location":"internals/utils/#Bramble.Backend","page":"Utilities","title":"Bramble.Backend","text":"struct Backend{VT<:AbstractVector,MT<:AbstractMatrix}\n\nA structure containing types and configuration for backend linear algebra objects. This structure has no fields, only types.\n\nThis allows specifying the desired concrete types for vectors and matrices (e.g., dense Vector, sparse SparseVector, different element types like Float32 or Float64).\n\n\n\n\n\n","category":"type"},{"location":"internals/utils/#Base.eltype-Union{Tuple{Bramble.Backend{VT, MT}}, Tuple{MT}, Tuple{VT}} where {VT, MT}","page":"Utilities","title":"Base.eltype","text":"eltype(backend::Backend)\n\nReturns the element type of the vector type (VT) used in the given Backend type or instance. This function allows querying the underlying element type stored in the backend's vector representation.\n\n\n\n\n\n","category":"method"},{"location":"internals/utils/#Bramble.backend-Tuple{}","page":"Utilities","title":"Bramble.backend","text":"backend(; vector_type, matrix_type)\n\n\nCreate a linear algebra Backend using keyword arguments.\n\nDefaults to standard dense Float64 vectors and SparseMatrixCSC matrices, ensuring the provided vector_type and matrix_type are constructible with the intended dimensions via standard patterns like T(undef, dims...) or T(dims...).\n\nExamples\n\njulia> dense_sparse = backend() # Default backend (Dense-Sparse Float64)\n\njulia> using SparseArrays;\n\t   SVec{T} = SparseVector{T,Int};\n\t   SMat{T} = SparseMatrixCSC{T,Int};\n\t   T64 = Float64\n\njulia> sparse_sparse = backend(vector_type = SVec{T64}, matrix_type = SMat{T64}) # Sparse-Sparse Float64 backend\n\njulia> T32 = Float32;\n\t   dense32 = backend(vector_type = Vector{T32}, matrix_type = SMat{T32}) # Dense-Sparse Float32 backend\n\n\n\n\n\n\n","category":"method"},{"location":"internals/utils/#Bramble.backend_eye-Tuple{Bramble.Backend, Any}","page":"Utilities","title":"Bramble.backend_eye","text":"backend_eye(backend::Backend, n)\n\nConstructs a square n x n sparse identity matrix associated with the given Backend instance.\n\n\n\n\n\n","category":"method"},{"location":"internals/utils/#Bramble.backend_types-Union{Tuple{Bramble.Backend{VT, MT}}, Tuple{MT}, Tuple{VT}} where {VT, MT}","page":"Utilities","title":"Bramble.backend_types","text":"backend_types(backend::Backend)\n\nReturns a tuple with the backend associated types:\n\nthe element type of VT,\nthe type VT,\nthe type MT,\nthe concrete backend type Backend{VT,MT}.\n\nThis is useful for extracting type information from either a Backend type or instance.\n\n\n\n\n\n","category":"method"},{"location":"internals/utils/#Bramble.backend_zeros-Tuple{Bramble.Backend, Any}","page":"Utilities","title":"Bramble.backend_zeros","text":"backend_zeros(backend::Backend, n)\n\nConstructs a square n x n sparse matrix of zeros associated with the given Backend instance.\n\n\n\n\n\n","category":"method"},{"location":"internals/utils/#Bramble.matrix-Tuple{Bramble.Backend, Integer, Integer}","page":"Utilities","title":"Bramble.matrix","text":"matrix(backend::Backend, n::Integer, m::Integer)\n\nCreate a matrix of the type MT associated with the given Backend instance with dimensions n x m.\n\n\n\n\n\n","category":"method"},{"location":"internals/utils/#Bramble.matrix_type-Union{Tuple{Bramble.Backend{VT, MT}}, Tuple{MT}, Tuple{VT}} where {VT, MT}","page":"Utilities","title":"Bramble.matrix_type","text":"matrix_type(backend::Backend)\n\nReturns the matrix type (MT) associated with the given Backend instance or type. This function is useful for extracting the underlying matrix type used by a specific backend.\n\n\n\n\n\n","category":"method"},{"location":"internals/utils/#Bramble.vector_type-Union{Tuple{Bramble.Backend{VT, MT}}, Tuple{MT}, Tuple{VT}} where {VT, MT}","page":"Utilities","title":"Bramble.vector_type","text":"vector_type(backend::Backend)\n\nReturns the vector type (VT) associated with the given Backend instance or type. This function is useful for extracting the underlying vector type used by a specific backend.\n\n\n\n\n\n","category":"method"},{"location":"internals/utils/#Linear-Algebra","page":"Utilities","title":"Linear Algebra","text":"","category":"section"},{"location":"internals/utils/#Bramble._dot-Union{Tuple{VT}, Tuple{T}, Tuple{VT, VT, VT}} where {T, VT<:AbstractVector{T}}","page":"Utilities","title":"Bramble._dot","text":"_dot(u, v, w)\n\n\nComputes the element-wise product of three vectors u, v, and w and sums the results. This is equivalent to the mathematical operation ∑ᵢ uᵢ * vᵢ * wᵢ. It is used as an optimized implementation for the weighted inner product of vectors.\n\nThe @fastmath macro allows for aggressive floating-point optimizations, and @simd instructs the compiler to vectorize the loop if possible.\n\n\n\n\n\n","category":"method"},{"location":"internals/utils/#Bramble._parallel_for!-Tuple{Any, Any, Any}","page":"Utilities","title":"Bramble._parallel_for!","text":"_parallel_for!(v, idxs, f)\n\n\nParallel implementation of a for loop that modifies array v in-place.\n\nArguments\n\nv: Array to be modified in-place\nidxs: Iterable of indices to process\nf: Function that takes an index and returns the value to be stored at that index\n\n\n\n\n\n","category":"method"},{"location":"internals/utils/#Bramble._serial_for!-Tuple{Any, Any, Any}","page":"Utilities","title":"Bramble._serial_for!","text":"_serial_for!(v, idxs, f)\n\n\nPerforms a serial (non-parallel) iteration over the specified indices, applying a function f to modify vector v in-place.\n\nArguments\n\nv: Vector to be modified in-place\nidxs: Indices to iterate over\nf: Function to be applied at each index\n\n\n\n\n\n","category":"method"},{"location":"internals/utils/#Bramble-Function","page":"Utilities","title":"Bramble Function","text":"","category":"section"},{"location":"internals/utils/#Bramble.BrambleFunction","page":"Utilities","title":"Bramble.BrambleFunction","text":"struct BrambleFunction{ArgsType, hastime, CoType, DType}\n\nInternal structure to wrap around functions to make them more type agnostic. It uses FunctionWrappers.jl wrap functions.\n\nFields\n\nwrapped: a FunctionWrapper wrapper for the function\ndomain: domain of the function; the standard is a CartesianProduct\n\nto provide functions calculated on ArgsType. The type arguments are hastime to indicate if the function is time-dependent and CoType, the time of the codomain of the function. It also stores the type of domain of the space part of the function (CartesianProduct)\n\n\n\n\n\n","category":"type"},{"location":"internals/utils/#Bramble._embed_notime-Tuple{Any, Any}","page":"Utilities","title":"Bramble._embed_notime","text":"_embed_notime(X, f; CoType)\n\n\nA convenience constructor for creating a time-independent (hastime=false) BrambleFunction. It's a simplified wrapper around bramble_function_with_domain.\n\n\n\n\n\n","category":"method"},{"location":"internals/utils/#Bramble._embed_withtime-Tuple{Any, Bramble.CartesianProduct{1}, Any}","page":"Utilities","title":"Bramble._embed_withtime","text":"_embed_withtime(space_domain, time_domain, f; FinalCoType)\n\n\nInternal implementation for embedding a time-dependent function f(x, t). When this function is called with a specific time t_val, it returns another space-only BrambleFunction, which represents the spatial function f(x, t_val) at that fixed time.\n\nArguments\n\nspace_domain: The spatial domain (CartesianProduct)\ntime_domain: The time domain (1D CartesianProduct)\nf: A function f(x, t) that takes spatial and time coordinates\nFinalCoType: The return type of f (optional, defaults to element type of time domain)\n\nReturns\n\nA BrambleFunction{ArgType,true,CoType,typeof(time_domain)} where calling it with time t returns a space-only BrambleFunction.\n\nExamples\n\nΩ = interval(0.0, 1.0)\nI = interval(0.0, 10.0)\nf(x, t) = sin(x * t)\nbf = _embed_withtime(Ω, I, f)\nbf_at_t5 = bf(5.0)  # Returns BrambleFunction for f(x, 5.0)\nbf_at_t5(0.5)       # Evaluates sin(0.5 * 5.0)\n\n\n\n\n\n","category":"method"},{"location":"internals/utils/#Bramble._get_args_type-Tuple{Any}","page":"Utilities","title":"Bramble._get_args_type","text":"_get_args_type(X)\n\n\nInternal helper to determine the expected argument type for a function based on a domain X.\n\nIf the domain is 1D (e.g., a line), the argument type is a scalar T.\nIf the domain is D-dimensional, the argument type is an NTuple{D,T}.\nT is the element type of the domain X.\n\nExamples\n\nX_1d = interval(0.0, 1.0)  # D=1, T=Float64\n_get_args_type(X_1d)  # Returns Float64\n\nX_2d = interval(0.0, 1.0) × interval(0.0, 1.0)  # D=2, T=Float64  \n_get_args_type(X_2d)  # Returns NTuple{2,Float64}\n\n\n\n\n\n","category":"method"},{"location":"internals/utils/#Bramble._get_domains-Tuple{Any}","page":"Utilities","title":"Bramble._get_domains","text":"_get_domains(domain_spec)\n\n\nParses a domain specification, which can be:\n\nA Symbol representing a spatial domain (e.g., :Ω).\nAn Expr representing the product of space and time domains (e.g., :(Ω × I)).\n\nReturns a tuple (space_domain_expr, time_domain_expr), where time_domain_expr is nothing if no time domain is specified.\n\n\n\n\n\n","category":"method"},{"location":"internals/utils/#Bramble.argstype-Union{Tuple{FunctionWrappers.FunctionWrapper{CoType, Tuple{ArgsType}}}, Tuple{ArgsType}, Tuple{CoType}} where {CoType, ArgsType}","page":"Utilities","title":"Bramble.argstype","text":"argstype(f::FunctionWrapper{CoType,Tuple{ArgsType}})\n\nExtracts the argument type ArgsType from a FunctionWrapper instance or type.\n\n\n\n\n\n","category":"method"},{"location":"internals/utils/#Bramble.bramble_function_with_domain-NTuple{4, Any}","page":"Utilities","title":"Bramble.bramble_function_with_domain","text":"bramble_function_with_domain(f, X, hastime, CoType; domain)\n\n\nA low-level constructor for creating a BrambleFunction. It wraps a given Julia function f into a FunctionWrapper and bundles it with its domain.\n\nArguments\n\nf: The function to wrap.\nX: The spatial domain used to infer the argument type of f.\nhastime: A boolean indicating if the function is time-dependent.\nCoType: The codomain (return) type of the function f.\ndomain: The actual domain object to store in the struct (typically X).\n\n\n\n\n\n","category":"method"},{"location":"internals/utils/#Bramble.codomaintype-Union{Tuple{FunctionWrappers.FunctionWrapper{CoType, Tuple{ArgsType}}}, Tuple{ArgsType}, Tuple{CoType}} where {CoType, ArgsType}","page":"Utilities","title":"Bramble.codomaintype","text":"codomaintype(f::FunctionWrapper{CoType})\n\nExtracts the codomain type CoType from a FunctionWrapper instance or type.\n\n\n\n\n\n","category":"method"},{"location":"internals/utils/#Bramble.embed_function-Tuple{Any, Any}","page":"Utilities","title":"Bramble.embed_function","text":"embed_function(space_domain, [time_domain], func)\n\nCreates a BrambleFunction for a function func defined over space_domain. If time_domain is provided, it creates a BrambleFunction for a time-dependent function func(x, t) defined over space_domain × time_domain.\n\n\n\n\n\n","category":"method"},{"location":"internals/utils/#Bramble.has_time-Union{Tuple{Bramble.BrambleFunction{ArgsType, hastime}}, Tuple{hastime}, Tuple{ArgsType}} where {ArgsType, hastime}","page":"Utilities","title":"Bramble.has_time","text":"has_time(f::BrambleFunction)\n\nChecks if a BrambleFunction is time-dependent by inspecting its hastime type parameter. Returns true if the function is time-dependent, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Documentation for Bramble.jl's public API.","category":"page"},{"location":"api/#Geometry-and-mesh","page":"API","title":"Geometry and mesh","text":"","category":"section"},{"location":"api/#Bramble.box","page":"API","title":"Bramble.box","text":"box(a::Number, b::Number)\nbox(a::NTuple, b::NTuple)\n\nCreates a CartesianProduct from two points a and b, which define the corners of the box. The component intervals are defined as min(a_i bᵢ) max(a_i b_i). It accepts both numbers (for 1D) and NTuple (for D-dimensions).\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.interval","page":"API","title":"Bramble.interval","text":"interval(x, y)\n\n\nConstructs a 1-dimensional CartesianProduct representing the closed interval x y. The inputs are converted to floating-point numbers. It also accepts an existing 1D CartesianProduct as a single argument.\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.:×","page":"API","title":"Bramble.:×","text":"×(X::CartesianProduct, Y::CartesianProduct)\n\nComputes the CartesianProduct of two CartesianProducts X and Y. The new dimension will be the sum of the dimensions of X and Y. Can be used as\n\nX × Y\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.dim","page":"API","title":"Bramble.dim","text":"dim(X::CartesianProduct)\n\nReturns the dimension of the space where the CartesianProduct is embedded. Can be applied directly to the type of the CartesianProduct.\n\nExamples\n\njulia> X = cartesian_product(0, 1);\n\t   dim(X)\n1\n\njulia> Y = cartesian_product(((0, 1), (4, 5)));\n\t   dim(Y)\n2\n\n\n\n\n\ndim(Ω::Domain)\n\nReturns the dimension of the ambient space where the Domain Ω is embedded. It can also be applied to the type of the domain.\n\nExample\n\njulia> I = interval(0.0, 1.0);\n\t   dim(domain(I × I))\n2\n\n\n\n\n\ndim(Ωₕ::AbstractMeshType)\n\nReturns the dimension of the space where Ωₕ is embedded.\n\nThis function is a required part of the AbstractMeshType interface. Can be applied to the type of an AbstractMeshType.\n\n\n\n\n\ndim(Wₕ::AbstractSpaceType)\n\nReturns the spatial dimension of the mesh associated with the functionpace Wₕ.\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.topo_dim","page":"API","title":"Bramble.topo_dim","text":"topo_dim(X::CartesianProduct)\n\nReturns the topological dimension of a CartesianProduct. The depends on the dimension of the CartesianProduct and the number of collapsed dimensions.\n\n\n\n\n\ntopo_dim(Ω::Domain)\n\nReturns the topological dimension Domain Ω.\n\n\n\n\n\ntopo_dim(Ωₕ::AbstractMeshType)\n\nReturns the topological dimension Ωₕ.\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.markers","page":"API","title":"Bramble.markers","text":"markers(space_set, [time_set], pairs...)\n\nConstructs a DomainMarkers object from a series of label => identifier pairs.\n\nThe identifier can be a Symbol, a Tuple of Symbols, or a Function. The full list of predefined boundary symbols can be found via get_boundary_symbols.\n\nExample\n\njulia> I = cartesian_product(0.0, 1.0);\n\t   tuples = (:corners => (:top, :right), :all_boundary => (:top, :right, :left, :bottom));\n\t   ids = (:left_boundary => :left, tuples..., :internal => x -> 0.2 < x < 0.8);\n\t   m = markers(I, ids...);\n\njulia> length(m.symbols)\n1\n\njulia> length(m.tuples)\n2\n\njulia> length(m.conditions)\n1\n\n\n\n\n\nmarkers(Ω::Domain)\n\nReturns the DomainMarkers object associated with the Domain Ω.\n\n\n\n\n\nmarkers(Ωₕ::AbstractMeshType)\n\nReturns the DomainMarkers) associated with the mesh Ωₕ. This function is a required part of the AbstractMeshType interface. Any concrete subtype of AbstractMeshType must implement this method and have a field called markers of type DomainMarkers.\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.domain","page":"API","title":"Bramble.domain","text":"domain(X::CartesianProduct, [markers...])\n\nReturns a Domain from a CartesianProduct, assuming a single Marker with the label :boundary that marks the whole boundary of X. Alternatively, a list of Marker can be passed as argument in the form of :symbol => key (see examples and markers).\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.labels","page":"API","title":"Bramble.labels","text":"labels(Ω::Domain)\n\nReturns a generator that yields the labels of all markers associated with the Domain Ω.\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.mesh","page":"API","title":"Bramble.mesh","text":"mesh(Ω::Domain, npts::Int, unif::Bool)\nmesh(Ω::Domain, npts::NTuple{D}, unif::NTuple{D})\n\nReturns a Mesh1D or a MeshnD (D=23) defined on the Domain Ω. The number of points for each coordinate projection mesh are given in the tuple npts. The distribution of points on the submeshes are encoded in the tuple unif.\n\nFor future reference, the mesh points are denoted as\n\n1D mesh, with npts = N_x\n\nx_i  i=1dotsN\n\n2D mesh, with npts = (N_x, N_y)\n\n(x_iy_j)  i=1dotsN_x  j=1dotsN_y\n\n3D mesh, with npts = (N_x, N_y, N_z)\n\n(x_iy_jz_l)  i=1dotsN_x  j=1dotsN_y  l=1dotsN_z\n\nExamples\n\nI = interval(0, 1);\nΩₕ = mesh(domain(I), 10, true);\n\nX = domain(interval(0, 1) × interval(4, 5));\nΩₕ = mesh(X, (10, 15), (true, false))\n\n\n\n\n\nmesh(Wₕ::AbstractSpaceType)\n\nReturns the underlying mesh object associated with the function space Wₕ.\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.points","page":"API","title":"Bramble.points","text":"points(Ωₕ::AbstractMeshType)\n\nReturns the points of Ωₕ either as a vector (1D case) or a tuple of vectors (nD case).\n\n1D mesh, with npts = N_x\n\nx_i  i=1dotsN_x\n\n2D mesh, with npts = (N_x, N_y)\n\n(x_i_i=1^N_x y_j_j=1^N_y)\n\n3D mesh, with npts = (N_x, N_y, N_z)\n\n(x_i_i=1^N_x y_j_j=1^N_y z_l_l=1^N_z)\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.hₘₐₓ","page":"API","title":"Bramble.hₘₐₓ","text":"hₘₐₓ(Ωₕ::AbstractMeshType)\n\nReturns the maximum diagonal of mesh Ωₕ.\n\n1D mesh\n\nh_max vcentcolon = max_i=1dotsN x_i - x_i-1\n\n2D mesh\n\nmax_ij Vert (h_xi h_yj) Vert_2\n\n3D mesh\n\nmax_ijl Vert (h_xi h_yj  h_zl) Vert_2\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.npoints","page":"API","title":"Bramble.npoints","text":"npoints(Ωₕ::AbstractMeshType, [::Type{Tuple}])\n\nReturns the number of points of mesh Ωₕ. If Tuple is passed as the second argument, it returns a tuple with the number of points of each submesh composing Ωₕ.\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.change_points!","page":"API","title":"Bramble.change_points!","text":"change_points!(Ωₕ::AbstractMeshType, [Ω::Domain], pts)\n\nChanges the coordinates of the internal points of the mesh Ωₕ to the new coordinates specified in pts. This function assumes the points in pts are ordered and that the first and last of them coincide with the bounds of the Ω. if the domain Ω is passed as an argument, the markers of the mesh are also recalculated after this change.\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.iterative_refinement!","page":"API","title":"Bramble.iterative_refinement!","text":"iterative_refinement!(Ωₕ::AbstractMeshType, [domain_markers::DomainMarkers])\n\nRefines the given mesh Ωₕ by halving each existing cell (in every direction). If an object of type DomainMarkers is passed as an argument, it also updates the markers according to accordingly after the refinement.\n\n\n\n\n\n","category":"function"},{"location":"api/#Space","page":"API","title":"Space","text":"","category":"section"},{"location":"api/#Bramble.gridspace","page":"API","title":"Bramble.gridspace","text":"gridspace(Ωₕ::AbstractMeshType{D}; cache_avg = false, cache_bwd = true)\n\nConstructor for a ScalarGridSpace defined on the mesh Ωₕ. This builds the weights for the inner products mentioned in ScalarGridSpace as well as the differentiation matrices associated with the grid points of mesh Ωₕ. The keyword arguments cache_avg and cache_bwd can be used to indicate if the average and backward difference matrices should be precomputed and stored in the space (default is true for cache_bwd and false for cache_avg).\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.element","page":"API","title":"Bramble.element","text":"element(Wₕ::AbstractSpaceType, [α::Number])\n\nReturns a VectorElement for grid space Wₕ with uninitialized components. if alpha is provided, the components are initialized to alpha.\n\n\n\n\n\nelement(Wₕ::AbstractSpaceType, v::AbstractVector)\n\nReturns a VectorElement for a grid space Wₕ with the same coefficients of v.\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.mesh-Tuple{Bramble.AbstractSpaceType}","page":"API","title":"Bramble.mesh","text":"mesh(Wₕ::AbstractSpaceType)\n\nReturns the underlying mesh object associated with the function space Wₕ.\n\n\n\n\n\n","category":"method"},{"location":"api/#Bramble.ndofs","page":"API","title":"Bramble.ndofs","text":"ndofs(Wₕ::AbstractSpaceType, [::Type{Tuple}])\n\nReturns the total number of degrees of freedom (DOFs) in the function space Wₕ. If Tuple is passed, it returns a tuple with the number of DOFs in each dimension.\n\n\n\n\n\n","category":"function"},{"location":"api/#Interpolation-operators","page":"API","title":"Interpolation operators","text":"","category":"section"},{"location":"api/#Bramble.avgₕ","page":"API","title":"Bramble.avgₕ","text":"avgₕ(Wₕ::AbstractSpaceType, f)\n\nReturns a VectorElement with the average of function f with respect to the cell_measure of mesh(Wₕ) around each grid point. It is defined as follows\n\n1D case\n\ntextrmavgₕ f(x_i) = frac1square_i int_square_i f(x) dx  i = 1dotsN\n\n2D case\n\ntextrmavgₕ f(x_i y_j) = frac1square_ij iint_square_ij f(xy) dA  i = 1dotsN_x  j = 1dotsN_y\n\n3D case\n\ntextrmavgₕ f(x_i y_j z_l) = frac1square_ijl iiint_square_ijl f(xyz) dV  i = 1dotsN_x  j = 1dotsN_y l = 1dotsN_z\n\nPlease check the implementations of functions cell_measure (for the 1-dimensional case) and cell_measure (for the n-dimensional cases).\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.avgₕ!","page":"API","title":"Bramble.avgₕ!","text":"avgₕ!(uₕ::VectorElement, f)\n\nIn-place version of averaging operator avgₕ.\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.Rₕ","page":"API","title":"Bramble.Rₕ","text":"Rₕ(Wₕ::AbstractSpaceType, f)\n\nStandard nodal restriction operator. It returns a VectorElement with the result of evaluating the function f at the points of mesh(Wₕ). It is defined as follows\n\n1D case\n\ntextrmRₕ f(x_i) = f(x_i)  i = 1dotsN\n\n2D case\n\ntextrmRₕ f(x_i y_j)= f(x_i y_j)  i = 1dotsN_x  j = 1dotsN_y\n\n3D case\n\ntextrmRₕ f(x_i y_j z_l)= f(x_i y_j z_l)  i = 1dotsN_x  j = 1dotsN_y l = 1dotsN_z\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.Rₕ!","page":"API","title":"Bramble.Rₕ!","text":"Rₕ!(uₕ::VectorElement, f; markers)\n\nIn-place version of the restriction operator Rₕ.\n\n\n\n\n\n","category":"function"},{"location":"api/#Differential-operators","page":"API","title":"Differential operators","text":"","category":"section"},{"location":"api/#Bramble.diff₋ₓ","page":"API","title":"Bramble.diff₋ₓ","text":"diff₋ₓ(arg)\n\nAlias for backward_difference(arg, Val(1)). Computes the backward difference in the x-direction.\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.diff₋ᵧ","page":"API","title":"Bramble.diff₋ᵧ","text":"diff₋ᵧ(arg)\n\nAlias for backward_difference(arg, Val(2)). Computes the backward difference in the y-direction.\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.diff₋₂","page":"API","title":"Bramble.diff₋₂","text":"diff₋₂(arg)\n\nAlias for backward_difference(arg, Val(3)). Computes the backward difference in the z-direction.\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.diff₋ₕ","page":"API","title":"Bramble.diff₋ₕ","text":"diff₋ₕ(arg)\n\nComputes the backward gradient of arg, returning a tuple of operators/elements for each spatial dimension.\n\nFor a 2D space, diff₋ₕ(uₕ) is equivalent to (backward_difference(uₕ, Val(1)), backward_difference(uₕ, Val(2))).\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.diff₊ₓ","page":"API","title":"Bramble.diff₊ₓ","text":"diff₊ₓ(arg)\n\nAlias for forward_difference(arg, Val(1)). Computes the forward difference in the x-direction.\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.diff₊ᵧ","page":"API","title":"Bramble.diff₊ᵧ","text":"diff₊ᵧ(arg)\n\nAlias for forward_difference(arg, Val(2)). Computes the forward difference in the y-direction.\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.diff₊₂","page":"API","title":"Bramble.diff₊₂","text":"diff₊₂(arg)\n\nAlias for forward_difference(arg, Val(3)). Computes the forward difference in the z-direction.\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.diff₊ₕ","page":"API","title":"Bramble.diff₊ₕ","text":"diff₊ₕ(arg)\n\nComputes the forward gradient of arg, returning a tuple of operators/elements for each spatial dimension.\n\nFor a 2D space, diff₊ₕ(uₕ) is equivalent to (forward_difference(uₕ, Val(1)), forward_difference(uₕ, Val(2))).\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.D₋ₓ","page":"API","title":"Bramble.D₋ₓ","text":"D₋ₓ(arg)\n\nAlias for backward_finite_difference(arg, Val(1)). Computes the backward difference in the x-direction.\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.D₋ᵧ","page":"API","title":"Bramble.D₋ᵧ","text":"D₋ᵧ(arg)\n\nAlias for backward_finite_difference(arg, Val(2)). Computes the backward difference in the y-direction.\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.D₋₂","page":"API","title":"Bramble.D₋₂","text":"D₋₂(arg)\n\nAlias for backward_finite_difference(arg, Val(3)). Computes the backward difference in the z-direction.\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.∇₋ₕ","page":"API","title":"Bramble.∇₋ₕ","text":"∇₋ₕ(arg)\n\nComputes the backward gradient of arg, returning a tuple of operators/elements for each spatial dimension.\n\nFor a 2D space, ∇₋ₕ(uₕ) is equivalent to (backward_finite_difference(uₕ, Val(1)), backward_finite_difference(uₕ, Val(2))).\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.D₊ₓ","page":"API","title":"Bramble.D₊ₓ","text":"D₊ₓ(arg)\n\nAlias for forward_finite_difference(arg, Val(1)). Computes the forward difference in the x-direction.\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.D₊ᵧ","page":"API","title":"Bramble.D₊ᵧ","text":"D₊ᵧ(arg)\n\nAlias for forward_finite_difference(arg, Val(2)). Computes the forward difference in the y-direction.\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.D₊₂","page":"API","title":"Bramble.D₊₂","text":"D₊₂(arg)\n\nAlias for forward_finite_difference(arg, Val(3)). Computes the forward difference in the z-direction.\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.∇₊ₕ","page":"API","title":"Bramble.∇₊ₕ","text":"∇₊ₕ(arg)\n\nComputes the forward gradient of arg, returning a tuple of operators/elements for each spatial dimension.\n\nFor a 2D space, ∇₊ₕ(uₕ) is equivalent to (forward_finite_difference(uₕ, Val(1)), forward_finite_difference(uₕ, Val(2))).\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.jump₋ₓ","page":"API","title":"Bramble.jump₋ₓ","text":"jump₋ₓ(arg)\n\nAlias for backward_jump(arg, Val(1)). Computes the backward difference in the x-direction.\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.jump₋ᵧ","page":"API","title":"Bramble.jump₋ᵧ","text":"jump₋ᵧ(arg)\n\nAlias for backward_jump(arg, Val(2)). Computes the backward difference in the y-direction.\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.jump₋₂","page":"API","title":"Bramble.jump₋₂","text":"jump₋₂(arg)\n\nAlias for backward_jump(arg, Val(3)). Computes the backward difference in the z-direction.\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.jump₋ₕ","page":"API","title":"Bramble.jump₋ₕ","text":"jump₋ₕ(arg)\n\nComputes the vectorial backward jump of arg, returning a tuple of operators/elements for each spatial dimension.\n\nFor a 2D space, jump₋ₕ(uₕ) is equivalent to (backward_jump(uₕ, Val(1)), backward_jump(uₕ, Val(2))).\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.jump₊ₓ","page":"API","title":"Bramble.jump₊ₓ","text":"jump₊ₓ(arg)\n\nAlias for forward_jump(arg, Val(1)). Computes the forward difference in the x-direction.\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.jump₊ᵧ","page":"API","title":"Bramble.jump₊ᵧ","text":"jump₊ᵧ(arg)\n\nAlias for forward_jump(arg, Val(2)). Computes the forward difference in the y-direction.\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.jump₊₂","page":"API","title":"Bramble.jump₊₂","text":"jump₊₂(arg)\n\nAlias for forward_jump(arg, Val(3)). Computes the forward difference in the z-direction.\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.jump₊ₕ","page":"API","title":"Bramble.jump₊ₕ","text":"jump₊ₕ(arg)\n\nComputes the vectorial forward jump of arg, returning a tuple of operators/elements for each spatial dimension.\n\nFor a 2D space, jump₊ₕ(uₕ) is equivalent to (forward_jump(uₕ, Val(1)), forward_jump(uₕ, Val(2))).\n\n\n\n\n\n","category":"function"},{"location":"api/#Average-operators","page":"API","title":"Average operators","text":"","category":"section"},{"location":"api/#Bramble.M₋ₓ","page":"API","title":"Bramble.M₋ₓ","text":"M₋ₓ(arg)\n\nAlias for backward_average(arg, Val(1)). Computes the backward difference in the x-direction.\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.M₋ᵧ","page":"API","title":"Bramble.M₋ᵧ","text":"M₋ᵧ(arg)\n\nAlias for backward_average(arg, Val(2)). Computes the backward difference in the y-direction.\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.M₋₂","page":"API","title":"Bramble.M₋₂","text":"M₋₂(arg)\n\nAlias for backward_average(arg, Val(3)). Computes the backward difference in the z-direction.\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.M₋ₕ","page":"API","title":"Bramble.M₋ₕ","text":"M₋ₕ(arg)\n\nComputes the vectorial backward average of arg, returning a tuple of operators/elements for each spatial dimension.\n\nFor a 2D space, M₋ₕ(uₕ) is equivalent to (backward_average(uₕ, Val(1)), backward_average(uₕ, Val(2))).\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.M₊ₓ","page":"API","title":"Bramble.M₊ₓ","text":"M₊ₓ(arg)\n\nAlias for forward_average(arg, Val(1)). Computes the forward difference in the x-direction.\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.M₊ᵧ","page":"API","title":"Bramble.M₊ᵧ","text":"M₊ᵧ(arg)\n\nAlias for forward_average(arg, Val(2)). Computes the forward difference in the y-direction.\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.M₊₂","page":"API","title":"Bramble.M₊₂","text":"M₊₂(arg)\n\nAlias for forward_average(arg, Val(3)). Computes the forward difference in the z-direction.\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.M₊ₕ","page":"API","title":"Bramble.M₊ₕ","text":"M₊ₕ(arg)\n\nComputes the vectorial forward average of arg, returning a tuple of operators/elements for each spatial dimension.\n\nFor a 2D space, M₊ₕ(uₕ) is equivalent to (forward_average(uₕ, Val(1)), forward_average(uₕ, Val(2))).\n\n\n\n\n\n","category":"function"},{"location":"api/#Inner-products-and-norms","page":"API","title":"Inner products and norms","text":"","category":"section"},{"location":"api/#Bramble.innerₕ","page":"API","title":"Bramble.innerₕ","text":"innerₕ(uₕ::VectorElement, vₕ::VectorElement)\n\nReturns the discrete L^2 inner product of the grid functions uₕ and vₕ. Also accepts MatrixElement as any of the arguments.\n\n1D case\n\n(textrmu_h textrmv_h)_h vcentcolon = sum_i=1^N square_i textrmu_h(x_i) textrmv_h(x_i)\n\n2D case\n\n(textrmu_h textrmv_h)_h vcentcolon = sum_i=1^N_x sum_j=1^N_y square_ij textrmu_h(x_iy_j) textrmv_h(x_iy_j)\n\n3D case\n\n(textrmu_h textrmv_h)_h vcentcolon = sum_i=1^N_x sum_j=1^N_y  sum_l=1^N_z  square_ijl textrmu_h(x_iy_j) textrmv_h(x_iy_j)\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.inner₊ₓ","page":"API","title":"Bramble.inner₊ₓ","text":"inner₊ₓ(uₕ::VecOrMatElem, vₕ::VecOrMatElem)\n\nReturns the discrete modified L^2 inner product of the grid functions uₕ and vₕ associated with the first variable. It accepts arguments of type VectorElement or MatrixElement, in any order.\n\nFor VectorElements, it is defined as\n\n1D case\n\n(textrmu_h textrmv_h)_+ vcentcolon = sum_i=1^N_x h_i textrmu_h(x_i) textrmv_h(x_i)\n\n2D case\n\n(textrmu_h textrmv_h)_+x vcentcolon = sum_i=1^N_xsum_j=1^N_y  h_xi h_yj+12  textrmu_h(x_iy_j) textrmv_h(x_iy_j)\n\n3D case\n\n(textrmu_h textrmv_h)_+x vcentcolon = sum_i=1^N_xsum_j=1^N_ysum_l=1^N_z   h_xi h_yj+12 h_zl+12  textrmu_h(x_iy_jz_l) textrmv_h(x_iy_jz_l)\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.inner₊ᵧ","page":"API","title":"Bramble.inner₊ᵧ","text":"inner₊ᵧ(uₕ::VecOrMatElem, vₕ::VecOrMatElem)\n\nReturns the discrete modified L^2 inner product of the grid functions uₕ and vₕ associated with the second variable. It accepts\n\n2D case\n\n(textrmu_h textrmv_h)_+y vcentcolon = sum_i=1^N_xsum_j=1^N_y   h_xi h_yj+12   textrmu_h(x_iy_j) textrmv_h(x_iy_j)\n\n3D case\n\n(textrmu_h textrmv_h)_+y vcentcolon = sum_i=1^N_xsum_j=1^N_ysum_l=1^N_z   h_xi+12 h_yj h_zl+12 textrmu_h(x_iy_jz_l) textrmv_h(x_iy_jz_l)\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.inner₊₂","page":"API","title":"Bramble.inner₊₂","text":"inner₊₂(uₕ::VecOrMatElem, vₕ::VecOrMatElem)\n\nReturns the discrete modified L^2 inner product of the grid functions uₕ and vₕ associated with the z variable\n\n(textrmu_h textrmv_h)_+z vcentcolon = sum_i=1^N_xsum_j=1^N_ysum_l=1^N_z  h_xi+12 h_yj+12 h_zl textrmu_h(x_iy_jz_l) textrmv_h(x_iy_jz_l)\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.inner₊","page":"API","title":"Bramble.inner₊","text":"inner₊(uₕ::VecOrMatElem, vₕ::VecOrMatElem, [::Type{Tuple}])\ninner₊(uₕ::NTuple{D}, vₕ::NTuple{D})\n\nReturns the discrete modified L^2 inner product of the grid functions uₕ and vₕ. It accepts arguments of type VectorElement or MatrixElement, in any order.\n\nIf the Tuple argument is given, it returns D-tuple of all textrminner_x_i+ applied to its input arguments, where D is the topological dimension of the mesh associated with the elements.\n\nIf NTuples of VectorElement or MatrixElement are passed as input arguments, it returns the sum of all inner products (textrmu_hitextrmv_hi)_+x_i.\n\nFor VectorElements, the definition is given by\n\n1D case\n\n(textrmu_h textrmv_h)_+ vcentcolon = sum_i=1^N_x h_i textrmu_h(x_i) textrmv_h(x_i)\n\n2D case\n\n(textrmu_h textrmv_h)_+ vcentcolon = (textrmu_h textrmv_h)_+x + (textrmu_h textrmv_h)_+y\n\n3D case\n\n(textrmu_h textrmv_h)_+ vcentcolon = (textrmu_h textrmv_h)_+x + (textrmu_h textrmv_h)_+y + (textrmu_h textrmv_h)_+z\n\nSee the definitions of inner₊ₓ, inner₊ᵧ and inner₊₂ for more details.\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.normₕ","page":"API","title":"Bramble.normₕ","text":"normₕ(uₕ::VectorElement)\n\nReturns the discrete L^2 norm of the grid function uₕ, defined as\n\nVert textrmu_h Vert_h vcentcolon = sqrt(textrmu_h textrmu_h)_h\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.norm₊","page":"API","title":"Bramble.norm₊","text":"norm₊(uₕ::VectorElement)\nnorm₊(uₕ::NTuple{D,VectorElement})\n\nReturns the discrete modified L^2 norm of the grid function uₕ. It also accepts a NTuple of VectorElements.\n\nFor VectorElements uₕ, it is defined as\n\nVert textrmu_h Vert_+ = sqrt(textrmu_htextrmu_h)_+\n\nand for NTuples of VectorElements it returns\n\nVert textrmu_h Vert_+ vcentcolon = sqrt sum_i=1^D(textrmu_hitextrmu_hi)_+x_i\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.snorm₁ₕ","page":"API","title":"Bramble.snorm₁ₕ","text":"snorm₁ₕ(uₕ::VectorElement)\n\nReturns the discrete version of the standard H^1 seminorm of VectorElement uₕ.\n\ntextrmu_h_1h vcentcolon = Vert nabla_h textrmu_h Vert_h\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.norm₁ₕ","page":"API","title":"Bramble.norm₁ₕ","text":"norm₁ₕ(uₕ::VectorElement)\n\nReturns the discrete version of the standard H^1 norm of VectorElement uₕ.\n\nVert textrmu_h Vert_1h vcentcolon = sqrt Vert textrmu_h Vert_h^2 +  Vert nabla_h textrmu_h Vert_h^2   \n\n\n\n\n\n","category":"function"},{"location":"api/#Form","page":"API","title":"Form","text":"","category":"section"},{"location":"api/#Bramble.dirichlet_constraints","page":"API","title":"Bramble.dirichlet_constraints","text":"dirichlet_constraints(cartesian_product, [I::CartesianProduct{1}], pairs...)\n\nCreates Dirichlet boundary constraints.\n\nEach pair is of the form :label => func, where :label identifies the boundary region and func defines the Dirichlet values. If the optional time domain I is provided, func should be a time-dependent function func(x, t).\n\nThe cartesian_product can be a CartesianProduct mesh domain or an ScalarGridSpace from which the mesh can be extracted. The :label must match a label in the mesh definition.\n\n\n\n\n\ndirichlet_constraints(X::CartesianProduct, f::Function)\n\nCreates a single Dirichlet boundary constraint with function `f` with the label `:dirichlet`.\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.form","page":"API","title":"Bramble.form","text":"form(Wₕ::AbstractSpaceType, Vₕ::AbstractSpaceType, f)\n\nReturns a bilinear form from a given expression and trial and test spaces.\n\n\n\n\n\nform(Wₕ::AbstractSpaceType, f)\n\nReturns a linear form from a given expression fand a test spaceWₕ`.\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.assemble","page":"API","title":"Bramble.assemble","text":"assemble(a::BilinearForm, [dirichlet_labels])\n\nReturns the assembled matrix of a bilinear form with imposed constraints.\n\n\n\n\n\nassemble(l::LinearForm)\n\nReturns the assembled linear form as a vector.\n\n\n\n\n\nassemble(l::LinearForm, dirichlet_conditions::DomainMarkers, [dirichlet_labels])\n\nReturns the assembled linear form with imposed constraints as a vector of numbers.\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.assemble!","page":"API","title":"Bramble.assemble!","text":"assemble!(A::AbstractMatrix, a::BilinearFormType [dirichlet_labels])\n\nCopies the assembled matrix of a bilinear form and imposes the Dirichlet constraints to a given matrix A.\n\n\n\n\n\nassemble!(vec::AbstractVector, l::LinearForm; dirichlet_conditions::DomainMarkers, [dirichlet_labels])\n\nIn-place assemble of a linear form with imposed constraints into a given vector.\n\n\n\n\n\n","category":"function"},{"location":"api/#Bramble.symmetrize!","page":"API","title":"Bramble.symmetrize!","text":"symmetrize!(A, F, Ωₕ, labels)\n\nModifies the linear system Ax = F to make A symmetric after applying Dirichlet conditions. It updates the vector F and zeros out the columns of A corresponding to Dirichlet nodes.\n\nThe algorithm goes as follows: for any given row i where Dirichlet boundary conditions have been applied\n\n- calculate `dᵢ = cᵢ .* F`, where `cᵢ` is the `i`-th column of `A`;\n- replace `F` by substracting `dᵢ` to `F` (except for the `i`-th component)\n- replace all elements in the `i`-th column of `A` (except the `i`-th by zero).\n\n\n\n\n\n","category":"function"},{"location":"internals/geometry/#Geometry","page":"Geometry","title":"Geometry","text":"","category":"section"},{"location":"internals/geometry/#Sets","page":"Geometry","title":"Sets","text":"","category":"section"},{"location":"internals/geometry/#Bramble.CartesianProduct","page":"Geometry","title":"Bramble.CartesianProduct","text":"struct CartesianProduct{D, T}\n\nA type representing the cartesian product of D closed intervals in a space with element type T.\n\nFields\n\nbox: a container of D pairs, where each pair represents the bounds (min, max) of an interval\ncollapsed: a container of D boolean values indicating whether each dimension is collapsed (i.e., min = max)\n\n\n\n\n\n","category":"type"},{"location":"internals/geometry/#Bramble.CartesianProduct-Tuple{Any}","page":"Geometry","title":"Bramble.CartesianProduct","text":"(X::CartesianProduct)(i)\n\nReturns the i-th interval (or point) in the CartesianProduct.\n\nExample\n\njulia> Y = cartesian_product(((0.0, 1.0), (4.0, 5.0)));\n\t   Y(2)\n(4.0, 5.0)\n\n\n\n\n\n","category":"method"},{"location":"internals/geometry/#Base.eltype-Union{Tuple{Bramble.CartesianProduct{D, T}}, Tuple{T}, Tuple{D}} where {D, T}","page":"Geometry","title":"Base.eltype","text":"eltype(X::CartesianProduct)\n\nReturns the element type of a CartesianProduct. Can be applied directly to the type of the CartesianProduct.\n\nExample\n\njulia> X = cartesian_product(0, 1);\n\t   eltype(X)\nFloat64\n\n\n\n\n\n","category":"method"},{"location":"internals/geometry/#Base.first-Tuple{Bramble.CartesianProduct{1}}","page":"Geometry","title":"Base.first","text":"first(X::CartesianProduct{1})\nlast(X::CartesianProduct{1})\n\nReturn the first and last elements of a one-dimensional CartesianProduct, respectively. These methods extend Base.first and Base.last for CartesianProduct{1}` types.\n\n\n\n\n\n","category":"method"},{"location":"internals/geometry/#Base.show-Union{Tuple{T}, Tuple{D}, Tuple{IO, Bramble.CartesianProduct{D, T}}} where {D, T}","page":"Geometry","title":"Base.show","text":"Base.show(io::IO, X::CartesianProduct)\n\nCustom display for CartesianProduct objects, showing dimension info and collapsed status with colors.\n\n\n\n\n\n","category":"method"},{"location":"internals/geometry/#Bramble.cartesian_product-Tuple{Any, Any}","page":"Geometry","title":"Bramble.cartesian_product","text":"cartesian_product(x, y)\ncartesian_product(box)\n\nReturns a CartesianProduct.\n\nIf D tuples are provided in box, it returns a D-dimensional CartesianProduct.\nIf two values x and y are provided, it returns a 1-dimensional CartesianProduct to represent the interval [x,y].\n\n\n\n\n\n","category":"method"},{"location":"internals/geometry/#Bramble.center-Union{Tuple{Bramble.CartesianProduct{D, T}}, Tuple{T}, Tuple{D}} where {D, T}","page":"Geometry","title":"Bramble.center","text":"center(cp::CartesianProduct{D,T}) -> SVector{D,T}\n\nReturns the center point of a CartesianProduct domain.\n\n\n\n\n\n","category":"method"},{"location":"internals/geometry/#Bramble.is_collapsed-Union{Tuple{T}, Tuple{T, T}} where T<:Number","page":"Geometry","title":"Bramble.is_collapsed","text":"is_collapsed(a::T, b::T)\nis_collapsed(X::CartesianProduct{1})\n\nChecks if a 1D CartesianProduct or two numbers are \"collapsed\" (i.e., degenerate).\n\nFor two numbers a and b, it returns true if they are approximately equal using isapprox.\nFor a 1-dimensional CartesianProduct, it returns the pre-computed collapse status stored in X.collapsed[1].\n\n\n\n\n\n","category":"method"},{"location":"internals/geometry/#Bramble.point-Tuple{Any}","page":"Geometry","title":"Bramble.point","text":"point(x)\n\n\nCreates a collapsed 1D CartesianProduct representing the point x x.\n\n\n\n\n\n","category":"method"},{"location":"internals/geometry/#Bramble.point_type-Union{Tuple{Bramble.CartesianProduct{1, T}}, Tuple{T}} where T","page":"Geometry","title":"Bramble.point_type","text":"point_type(X::CartesianProduct)\n\nDetermines the type of a coordinate point within a CartesianProduct space. Returns T for 1D spaces and NTuple{D,T} for D-dimensional spaces.\n\n\n\n\n\n","category":"method"},{"location":"internals/geometry/#Bramble.projection-Tuple{Bramble.CartesianProduct, Any}","page":"Geometry","title":"Bramble.projection","text":"projection(X::CartesianProduct, i)\n\nReturns the i-th component interval of X` as a new 1D CartesianProduct.\n\n\n\n\n\n","category":"method"},{"location":"internals/geometry/#Bramble.set-Tuple{Bramble.CartesianProduct}","page":"Geometry","title":"Bramble.set","text":"set(X::CartesianProduct)\n\nReturns the CartesianProduct itself. This can be useful for functions that expect a domain object and might receive either the object or a wrapper.\n\n\n\n\n\n","category":"method"},{"location":"internals/geometry/#Bramble.tails-Tuple{Bramble.CartesianProduct, Any}","page":"Geometry","title":"Bramble.tails","text":"tails(X::CartesianProduct, i)\n\nReturns the i-th component interval of the CartesianProduct X as a Tuple. This is an alias for X(i).\n\n\n\n\n\n","category":"method"},{"location":"internals/geometry/#Bramble.tails-Tuple{Bramble.CartesianProduct{1}}","page":"Geometry","title":"Bramble.tails","text":"tails(X::CartesianProduct)\n\nReturns the component sets of a CartesianProduct:\n\nfor a one-dimensional CartesianProduct (D=1), returns the single component set.\nfor a D-dimensional CartesianProduct, returns a tuple containing all component sets.\n\n\n\n\n\n","category":"method"},{"location":"internals/geometry/#Markers","page":"Geometry","title":"Markers","text":"","category":"section"},{"location":"internals/geometry/#Bramble.DomainMarkers","page":"Geometry","title":"Bramble.DomainMarkers","text":"struct DomainMarkers{BFType}\n\nA container that categorizes and stores all markers for a given domain.\n\nSee markers for construction and get_boundary_symbols for available predefined boundary symbols.\n\nFields\n\nsymbols: markers identified by a single predefined Symbol (e.g., :left).\ntuples: markers identified by a collection of predefined Symbols (e.g., (:top, :right)).\nconditions: markers identified by a boolean function f(x) or f(x, t).\n\n\n\n\n\n","category":"type"},{"location":"internals/geometry/#Bramble.DomainMarkers-Tuple{Number}","page":"Geometry","title":"Bramble.DomainMarkers","text":"(dm::DomainMarkers)(t::Number)\n\nEvaluates a time-dependent DomainMarkers object at a specific time t. This function returns a new, time-independent DomainMarkers object.\n\nExample\n\njulia> time_dep_markers = markers(space_domain, time_domain, :moving_front => (x, t) -> x[1] > t);\n\t   markers_at_0_5 = time_dep_markers(0.5)# Symbol and Tuple markers are time-agnostic, so they are preserved.\n\n\n\n\n\n\n","category":"method"},{"location":"internals/geometry/#Bramble.EvaluatedDomainMarkers","page":"Geometry","title":"Bramble.EvaluatedDomainMarkers","text":"struct EvaluatedDomainMarkers{M<:Bramble.DomainMarkers, T<:Number}\n\nA lazy, view-like wrapper that represents a DomainMarkers object evaluated at a specific time t.\n\nThis struct avoids allocating a new collection for time-evaluated functions. Instead, it generates the time-independent functions on-the-fly when the conditions are iterated over. It shares the symbols and tuples directly from the original object.\n\nFields\n\noriginal_markers\nevaluation_time\n\n\n\n\n\n","category":"type"},{"location":"internals/geometry/#Bramble.Marker","page":"Geometry","title":"Bramble.Marker","text":"struct Marker{F}\n\nRepresents a labeled region or boundary of a domain.\n\nEach Marker consists of a label (a Symbol) and an identifier. The identifier specifies how to locate the marked region. It can be:\n\nA Symbol for predefined boundaries (e.g., :left, :top).\nA Set{Symbol} for collections of predefined boundaries.\nA function (wrapped in a BrambleFunction) that acts as a level-set, returning true for points inside the marked region.\n\nFields\n\nlabel: A Symbol used to name the marked region (e.g., :inlet, :wall).\nidentifier: The object that identifies the region (Symbol, Set{Symbol}, or BrambleFunction).\n\n\n\n\n\n","category":"type"},{"location":"internals/geometry/#Bramble.MarkerPair","page":"Geometry","title":"Bramble.MarkerPair","text":"MarkerPair{F}\n\nA type alias for Pair{Symbol, F}, representing a convenient way to define a marker. For example: :boundary => :left.\n\n\n\n\n\n","category":"type"},{"location":"internals/geometry/#Base.isempty-Tuple{Bramble.DomainMarkers}","page":"Geometry","title":"Base.isempty","text":"Base.isempty(dm::DomainMarkers)\n\nChecks if a DomainMarkers object contains any markers.\n\n\n\n\n\n","category":"method"},{"location":"internals/geometry/#Base.length-Tuple{Bramble.DomainMarkers}","page":"Geometry","title":"Base.length","text":"Base.length(dm::DomainMarkers)\n\nReturns the total number of markers in a DomainMarkers object.\n\n\n\n\n\n","category":"method"},{"location":"internals/geometry/#Base.show-Tuple{IO, Bramble.DomainMarkers}","page":"Geometry","title":"Base.show","text":"Base.show(io::IO, dm::DomainMarkers)\n\nCustom display for DomainMarkers objects with detailed marker information and colors.\n\n\n\n\n\n","category":"method"},{"location":"internals/geometry/#Base.show-Union{Tuple{F}, Tuple{IO, Bramble.Marker{F}}} where F","page":"Geometry","title":"Base.show","text":"Base.show(io::IO, m::Marker)\n\nCustom display for Marker objects.\n\n\n\n\n\n","category":"method"},{"location":"internals/geometry/#Bramble.conditions-Tuple{Bramble.DomainMarkers}","page":"Geometry","title":"Bramble.conditions","text":"conditions(domain_markers::DomainMarkers)\n\nGets the set of function-based markers from a DomainMarkers object.\n\n\n\n\n\n","category":"method"},{"location":"internals/geometry/#Bramble.conditions-Tuple{Bramble.EvaluatedDomainMarkers}","page":"Geometry","title":"Bramble.conditions","text":"conditions(edm::EvaluatedDomainMarkers)\n\nReturns a lazy generator that yields time-evaluated markers.\n\nThis is the core of the lazy evaluation. It iterates over the original conditions and yields new Marker objects with their functions evaluated at edm.evaluation_time, but only when requested.\n\n\n\n\n\n","category":"method"},{"location":"internals/geometry/#Bramble.identifier-Tuple{Bramble.Marker}","page":"Geometry","title":"Bramble.identifier","text":"identifier(m::Marker)\nidentifier(m::MarkerPair)\n\nReturns the identifier (Symbol, Set, or function) of a Marker or MarkerPair.\n\n\n\n\n\n","category":"method"},{"location":"internals/geometry/#Bramble.label-Tuple{Bramble.Marker}","page":"Geometry","title":"Bramble.label","text":"label(m::Marker)\nlabel(m::MarkerPair)\n\nReturns the Symbol label of a Marker or MarkerPair.\n\n\n\n\n\n","category":"method"},{"location":"internals/geometry/#Bramble.label_conditions-Tuple{Bramble.DomainMarkers}","page":"Geometry","title":"Bramble.label_conditions","text":"label_conditions(domain_markers::DomainMarkers)\n\nReturns a generator that yields the labels from the function-based markers.\n\n\n\n\n\n","category":"method"},{"location":"internals/geometry/#Bramble.label_identifiers-Tuple{Bramble.DomainMarkers}","page":"Geometry","title":"Bramble.label_identifiers","text":"label_identifiers(domain_markers::DomainMarkers)\n\nReturns a generator that yields the label of every marker in the DomainMarkers collection.\n\n\n\n\n\n","category":"method"},{"location":"internals/geometry/#Bramble.label_symbols-Tuple{Bramble.DomainMarkers}","page":"Geometry","title":"Bramble.label_symbols","text":"label_symbols(domain_markers::DomainMarkers)\n\nReturns a generator that yields the labels from the single-symbol markers.\n\n\n\n\n\n","category":"method"},{"location":"internals/geometry/#Bramble.label_tuples-Tuple{Bramble.DomainMarkers}","page":"Geometry","title":"Bramble.label_tuples","text":"label_tuples(domain_markers::DomainMarkers)\n\nReturns a generator that yields the labels from the symbol-tuple markers.\n\n\n\n\n\n","category":"method"},{"location":"internals/geometry/#Bramble.symbols-Tuple{Bramble.DomainMarkers}","page":"Geometry","title":"Bramble.symbols","text":"symbols(domain_markers::DomainMarkers)\n\nGets the set of single-symbol markers from a DomainMarkers object.\n\n\n\n\n\n","category":"method"},{"location":"internals/geometry/#Bramble.tuples-Tuple{Bramble.DomainMarkers}","page":"Geometry","title":"Bramble.tuples","text":"tuples(domain_markers::DomainMarkers)\n\nGets the set of symbol-tuple markers from a DomainMarkers object.\n\n\n\n\n\n","category":"method"},{"location":"internals/geometry/#Domains","page":"Geometry","title":"Domains","text":"","category":"section"},{"location":"internals/geometry/#Bramble.Domain","page":"Geometry","title":"Bramble.Domain","text":"struct Domain{SetType, MarkersType} <: Bramble.DomainBaseType\n\nRepresents a computational domain, which combines a geometric set with a collection of labeled markers.\n\nThis struct is a fundamental building block, bundling a geometric entity (a CartesianProduct) with a DomainMarkers object that defines named regions (like boundaries or subdomains).\n\nFields\n\nset: the geometric set defining the domain's extent (e.g., a CartesianProduct).\nmarkers: a DomainMarkers object containing all labeled regions for this domain.\n\nRelated Types\n\nUse mesh to discretize a Domain into a computational mesh (Mesh1D or MeshnD).\nSee CartesianProduct for the underlying geometric representation.\nSee DomainMarkers for marker management.\n\n\n\n\n\n","category":"type"},{"location":"internals/geometry/#Base.eltype-Tuple{Bramble.Domain}","page":"Geometry","title":"Base.eltype","text":"eltype(Ω::Domain)\n\nReturns the type of the bounds defining Domain Ω. It can also be applied to the type of the domain. It can be applied also to the type of the domain.\n\nExample\n\njulia> I = interval(0.0, 1.0);\n\t   eltype(domain(I × I))\nFloat64\n\n\n\n\n\n","category":"method"},{"location":"internals/geometry/#Base.show-Tuple{IO, Bramble.Domain}","page":"Geometry","title":"Base.show","text":"Base.show(io::IO, Ω::Domain)\n\nCustom display for Domain objects, combining set and marker information with colors.\n\n\n\n\n\n","category":"method"},{"location":"internals/geometry/#Bramble.get_boundary_symbols-Tuple{Bramble.CartesianProduct{1}}","page":"Geometry","title":"Bramble.get_boundary_symbols","text":"get_boundary_symbols(X::CartesianProduct)\n\nReturns a tuple of default boundary symbols for a CartesianProduct.\n\nin 1D [x₁,x₂], :left (x=x₁), :right (x=x₂)\nin 2D [x₁,x₂] × [y₁,y₂], :left (x=x₁), :right (x=x₂), :top (y=y₂), :bottom (y=y₁)\nin 3D [x₁,x₂] × [y₁,y₂] × [z₁,z₂], :front (x=x₂), :back (x=x₁), :left (y=y₁), :right (y=y₂), :top (z=z₃), :bottom (z=z₁)\n\n\n\n\n\n","category":"method"},{"location":"internals/geometry/#Bramble.label_conditions-Tuple{Bramble.Domain}","page":"Geometry","title":"Bramble.label_conditions","text":"label_conditions(Ω::Domain)\n\nReturns a generator with the labels of the conditions on DomainMarkers.\n\n\n\n\n\n","category":"method"},{"location":"internals/geometry/#Bramble.label_identifiers-Tuple{Bramble.Domain}","page":"Geometry","title":"Bramble.label_identifiers","text":"label_identifiers(Ω::Domain)\n\nReturns a generator with all labels on DomainMarkers.\n\n\n\n\n\n","category":"method"},{"location":"internals/geometry/#Bramble.label_symbols-Tuple{Bramble.Domain}","page":"Geometry","title":"Bramble.label_symbols","text":"label_symbols(Ω::Domain)\n\nReturns a generator with the labels of the symbols on DomainMarkers.\n\n\n\n\n\n","category":"method"},{"location":"internals/geometry/#Bramble.label_tuples-Tuple{Bramble.Domain}","page":"Geometry","title":"Bramble.label_tuples","text":"label_tuples(Ω::Domain)\n\nReturns a generator with the labels of the tuples on DomainMarkers.\n\n\n\n\n\n","category":"method"},{"location":"internals/geometry/#Bramble.marker_conditions-Tuple{Bramble.Domain}","page":"Geometry","title":"Bramble.marker_conditions","text":"marker_conditions(Ω::Domain)\n\nReturns a generator yielding the identifiers (functions) of condition-based markers.\n\n\n\n\n\n","category":"method"},{"location":"internals/geometry/#Bramble.marker_identifiers-Tuple{Bramble.Domain}","page":"Geometry","title":"Bramble.marker_identifiers","text":"marker_identifiers(Ω::Domain)\n\nReturns a generator that yields the identifiers (Symbol, Set{Symbol}, or BrambleFunction) of all markers associated with the Domain Ω.\n\n\n\n\n\n","category":"method"},{"location":"internals/geometry/#Bramble.marker_symbols-Tuple{Bramble.Domain}","page":"Geometry","title":"Bramble.marker_symbols","text":"marker_symbols(Ω::Domain)\n\nReturns a generator yielding the identifiers of single-symbol markers.\n\n\n\n\n\n","category":"method"},{"location":"internals/geometry/#Bramble.marker_tuples-Tuple{Bramble.Domain}","page":"Geometry","title":"Bramble.marker_tuples","text":"marker_tuples(Ω::Domain)\n\nReturns a generator yielding the identifiers of symbol-tuple markers.\n\n\n\n\n\n","category":"method"},{"location":"internals/geometry/#Bramble.projection-Tuple{Bramble.Domain, Any}","page":"Geometry","title":"Bramble.projection","text":"projection(Ω::Domain, i)\n\nReturns the i-th CartesianProduct of the set associated with Domain Ω.\n\nFor example, projection(domain(I × I), 1) will return I.\n\n\n\n\n\n","category":"method"},{"location":"internals/geometry/#Bramble.set-Tuple{Bramble.Domain}","page":"Geometry","title":"Bramble.set","text":"set(Ω::Domain)\n\nReturns the CartesianProduct associated with the Domain Ω.\n\n\n\n\n\n","category":"method"},{"location":"internals/form/#Forms","page":"Forms","title":"Forms","text":"","category":"section"},{"location":"internals/form/#Bramble.DirichletConstraint","page":"Forms","title":"Bramble.DirichletConstraint","text":"struct DomainMarkers{FType}\n\nAlias for storage of Dirichlet constraints.\n\n\n\n\n\n","category":"type"},{"location":"internals/form/#Bramble._dirichlet_bc_indices!-Tuple{AbstractMatrix, BitVector}","page":"Forms","title":"Bramble._dirichlet_bc_indices!","text":"_dirichlet_bc_indices!(A, marker_indices)\n\nInternal helper to apply Dirichlet boundary conditions to matrix A for a given set of indices.\n\n\n\n\n\n","category":"method"},{"location":"internals/form/#Bramble._dirichlet_bc_indices!-Tuple{SparseArrays.SparseMatrixCSC, BitVector}","page":"Forms","title":"Bramble._dirichlet_bc_indices!","text":"dirichletbcindices!(A::SparseMatrixCSC, indexin_marker::BitVector)\n\nApplies Dirichlet boundary conditions to a sparse matrix A by directly manipulating its CSC data structure for high performance.\n\n\n\n\n\n","category":"method"},{"location":"internals/form/#Bramble.dirichlet_bc!-Tuple{AbstractMatrix, Bramble.AbstractMeshType, Vararg{Symbol}}","page":"Forms","title":"Bramble.dirichlet_bc!","text":"dirichlet_bc!(A::AbstractMatrix, Ωₕ::AbstractMeshType, labels::Symbol...)\n\nApplies Dirichlet boundary conditions to matrix A based on marked regions in the mesh Ωₕ.\n\nFor each index i associated with the given Dirichlet labels, this function:\n\nSets all elements in the i-th row of A to zero.\nSets the diagonal element A[i, i] to one.\n\n\n\n\n\n","category":"method"},{"location":"internals/form/#Bramble.dirichlet_bc!-Tuple{AbstractVector, Bramble.AbstractMeshType, Bramble.DomainMarkers, Vararg{Symbol}}","page":"Forms","title":"Bramble.dirichlet_bc!","text":"dirichlet_bc!(v::AbstractVector, Ωₕ::AbstractMeshType, bcs::DirichletConstraint, labels::Symbol...)\n\nApply Dirichlet boundary conditions to vector v using the DirichletConstraint object bcs and the mesh Ωₕ.\n\n\n\n\n\n","category":"method"},{"location":"internals/form/#Bramble.symmetrize!-Tuple{AbstractMatrix, AbstractVector, Bramble.AbstractMeshType, Vararg{Symbol}}","page":"Forms","title":"Bramble.symmetrize!","text":"symmetrize!(A, F, Ωₕ, labels)\n\nModifies the linear system Ax = F to make A symmetric after applying Dirichlet conditions. It updates the vector F and zeros out the columns of A corresponding to Dirichlet nodes.\n\nThe algorithm goes as follows: for any given row i where Dirichlet boundary conditions have been applied\n\n- calculate `dᵢ = cᵢ .* F`, where `cᵢ` is the `i`-th column of `A`;\n- replace `F` by substracting `dᵢ` to `F` (except for the `i`-th component)\n- replace all elements in the `i`-th column of `A` (except the `i`-th by zero).\n\n\n\n\n\n","category":"method"},{"location":"internals/form/#Bramble.LinearForm","page":"Forms","title":"Bramble.LinearForm","text":"struct LinearForm{TestType,F} <: LinearFormType\n\ttest_space::TestType\n\tform_expr::F\nend\n\nStructure to store the data associated with a llinear form\n\nbeginarrayrcll\nl colon  W_h longrightarrow mathbbR \n\t\t    v  longmapsto  l(v)\nendarray\n\nThe field form_expr has the expression of the form and the remaining field stores the test space W_h.\n\n\n\n\n\n","category":"type"},{"location":"internals/form/#Bramble.LinearFormType","page":"Forms","title":"Bramble.LinearFormType","text":"LinearFormType\n\nAbstract type for linear forms.\n\n\n\n\n\n","category":"type"},{"location":"internals/form/#Bramble._assemble!-Tuple{AbstractVector, Bramble.LinearForm}","page":"Forms","title":"Bramble._assemble!","text":"_assemble!(x::AbstractVector, l::LinearForm)\n\nIn-place assemble of a linear form into a given vector.\n\n\n\n\n\n","category":"method"},{"location":"internals/form/#Bramble._assemble!-Tuple{Bramble.VectorElement, Bramble.LinearForm}","page":"Forms","title":"Bramble._assemble!","text":"_assemble!(uₕ::VectorElement, l::LinearForm)\n\nIn-place assemble of a linear form into a given VectorElement.\n\n\n\n\n\n","category":"method"},{"location":"internals/form/#Bramble.test_space-Tuple{Bramble.LinearForm}","page":"Forms","title":"Bramble.test_space","text":"test_space(a::LinearForm)\n\nReturns the test space of a linear form.\n\n\n\n\n\n","category":"method"},{"location":"internals/form/#Bramble.BilinearForm","page":"Forms","title":"Bramble.BilinearForm","text":"struct BilinearForm{TrialType,TestType,F} <: BilinearFormType\n\ttrial_space::TrialType\n\ttest_space::TestType\n\tform_expr::F\nend\n\nStructure to store the data associated with a bilinear form\n\nbeginarrayrcll\na colon  W_h times V_h longrightarrow mathbbR \n\t\t         (uv)     longmapsto  a(uv)\nendarray\n\nThe field form_expr has the expression of the form and the remaining fields store the trial and test spaces W_h and V_h.\n\n\n\n\n\n","category":"type"},{"location":"internals/form/#Bramble.BilinearFormType","page":"Forms","title":"Bramble.BilinearFormType","text":"BilinearFormType\n\nAbstract type for bilinear forms.\n\n\n\n\n\n","category":"type"},{"location":"internals/form/#Bramble._assemble!-Tuple{AbstractMatrix, Bramble.BilinearForm}","page":"Forms","title":"Bramble._assemble!","text":"_assemble!(A::AbstractMatrix, a::BilinearForm)\n\nHelper function. Copies the assembled matrix of a bilinear form to a given matrix.\n\n\n\n\n\n","category":"method"},{"location":"internals/form/#Bramble._assemble-Tuple{Bramble.BilinearForm}","page":"Forms","title":"Bramble._assemble","text":"_assemble(a::BilinearForm)\n\nHelper function. Returns the assembled matrix of a bilinear form.\n\n\n\n\n\n","category":"method"},{"location":"internals/form/#Bramble.test_space-Tuple{Bramble.BilinearFormType}","page":"Forms","title":"Bramble.test_space","text":"test_space(a::BilinearForm)\n\nReturns the test space of a bilinear form.\n\n\n\n\n\n","category":"method"},{"location":"internals/form/#Bramble.trial_space-Tuple{Bramble.BilinearFormType}","page":"Forms","title":"Bramble.trial_space","text":"trial_space(a::BilinearForm)\n\nReturns the trial space of a bilinear form.\n\n\n\n\n\n","category":"method"},{"location":"internals/mesh/#Mesh","page":"Mesh","title":"Mesh","text":"","category":"section"},{"location":"internals/mesh/#Bramble.AbstractMeshType","page":"Mesh","title":"Bramble.AbstractMeshType","text":"AbstractMeshType{D}\n\nAbstract supertype for all mesh types in Bramble. The type parameter D represents the spatial dimension of the mesh (1, 2, or 3).\n\nAll concrete mesh types must implement the AbstractMeshType interface, including:\n\neltype, dim, topo_dim, indices, backend, markers\npoints, point, half_points, half_point\nspacing, half_spacing, forward_spacing\n\nRelated Types\n\nMeshes are created from a Domain using the mesh function.\nSee MeshMarkers for marker management on meshes.\n\nSee also: Mesh1D, MeshnD, Domain\n\n\n\n\n\n","category":"type"},{"location":"internals/mesh/#Base.eltype-Tuple{Bramble.AbstractMeshType}","page":"Mesh","title":"Base.eltype","text":"eltype(Ωₕ::AbstractMeshType)\n\nReturns the element type of the points of Ωₕ.\n\nThis function is a required part of the AbstractMeshType interface.\n\n\n\n\n\n","category":"method"},{"location":"internals/mesh/#Bramble.backend-Tuple{Bramble.AbstractMeshType}","page":"Mesh","title":"Bramble.backend","text":"backend(Ωₕ::AbstractMeshType)\n\nReturns the linear algebra Backend associated with the mesh Ωₕ. This function is a required part of the AbstractMeshType interface. Any concrete subtype of AbstractMeshType must implement this method and have a field called backend of type Backend.\n\n\n\n\n\n","category":"method"},{"location":"internals/mesh/#Bramble.boundary_indices-Tuple{Bramble.AbstractMeshType}","page":"Mesh","title":"Bramble.boundary_indices","text":"boundary_indices(Ωₕ::AbstractMeshType)\n\nReturns an iterator or collection of all CartesianIndex points on the boundary of mesh Ωₕ.\n\n\n\n\n\n","category":"method"},{"location":"internals/mesh/#Bramble.boundary_indices-Tuple{CartesianIndices}","page":"Mesh","title":"Bramble.boundary_indices","text":"boundary_indices(idxs::CartesianIndices)\n\nReturns all boundary facets of a CartesianIndices domain as a tuple of CartesianIndices. Each element of the returned tuple represents a distinct boundary section, such as a face or edge of the domain.\n\nExample\n\njulia> domain = CartesianIndices((2, 2));\n\t   boundary_indices(domain)\n(CartesianIndices((1:1, 1:2)), CartesianIndices((2:2, 1:2)), CartesianIndices((1:2, 1:1)), CartesianIndices((1:2, 2:2)))\n\n\n\n\n\n","category":"method"},{"location":"internals/mesh/#Bramble.cell_measure-Tuple{Bramble.AbstractMeshType, Any}","page":"Mesh","title":"Bramble.cell_measure","text":"cell_measure(Ωₕ::AbstractMeshType, idx)\n\nReturns the measure of the cell square_idx centered at the index idx (can be a CartesianIndex or a Tuple):\n\n1D mesh, with idx = (i)\n\nsquare_i vcentcolon = leftx_i - frach_i2 x_i + frach_i+12 right\n\nat CartesianIndex i in mesh Ωₕ, which is given by h_i+12\n\n2D mesh\n\n  square_ij vcentcolon = leftx_i - frach_xi2 x_i + frach_xi+12 right times lefty_j - frach_yj2 y_j + frach_yj+12 right\n\nwith area h_xi+12 h_yj+12, where idx = (ij),\n\n3D mesh\n\nsquare_ijl vcentcolon = leftx_i - frach_xi2 x_i + frach_xi+12right times lefty_j - frach_yj2 y_j + frach_yj+12right times leftz_l - frach_zl2 z_l + frach_zl+12right\n\nwith volume h_xi+12 h_yj+12 h_zl+12, where idx = (ijl).\n\n\n\n\n\n","category":"method"},{"location":"internals/mesh/#Bramble.cell_measure_iterator-Tuple{Bramble.AbstractMeshType}","page":"Mesh","title":"Bramble.cell_measure_iterator","text":"cell_measure_iterator(Ωₕ::AbstractMeshType)\n\nReturns an iterator for the measure of the cells.\n\n\n\n\n\n","category":"method"},{"location":"internals/mesh/#Bramble.change_points!-Tuple{Bramble.AbstractMeshType, Any}","page":"Mesh","title":"Bramble.change_points!","text":"change_points!(Ωₕ::AbstractMeshType, [Ω::Domain], pts)\n\nChanges the coordinates of the internal points of the mesh Ωₕ to the new coordinates specified in pts. This function assumes the points in pts are ordered and that the first and last of them coincide with the bounds of the Ω. if the domain Ω is passed as an argument, the markers of the mesh are also recalculated after this change.\n\n\n\n\n\n","category":"method"},{"location":"internals/mesh/#Bramble.dimension-Tuple{Type{<:Tuple{T} where T}}","page":"Mesh","title":"Bramble.dimension","text":"dimension(::Type{<:NTuple{D}}) -> Dimension\ndimension(::Type{<:SVector{D}}) -> Dimension\n\nMaps a tuple or SVector type to its corresponding dimension type for compile-time dispatch. Used internally for efficient method selection in generate_indices and similar functions.\n\n\n\n\n\n","category":"method"},{"location":"internals/mesh/#Bramble.forward_spacing-Tuple{Bramble.AbstractMeshType, Any}","page":"Mesh","title":"Bramble.forward_spacing","text":"forward_spacing(Ωₕ::AbstractMeshType, idx)\n\nReturns a tuple with the forward_spacing, for each submesh, at index idx.\n\n1D mesh, with idx = (i) or i\n\nh_xi vcentcolon = x_i+1 - x_i  i=1dotsN-1\n\nand h_xN vcentcolon = x_N - x_N-1\n\n2D mesh, with idx = (ij)\n\n(h_xi h_yj) vcentcolon = (x_i+1 - x_i y_j+1 - y_j)\n\n3D mesh, with idx = (ijl)\n\n(h_xi h_yj h_zl) vcentcolon = (x_i+1 - x_i y_j+1 - y_j z_l+1 - z_l)\n\n\n\n\n\n","category":"method"},{"location":"internals/mesh/#Bramble.forward_spacings_iterator-Tuple{Bramble.AbstractMeshType}","page":"Mesh","title":"Bramble.forward_spacings_iterator","text":"spacings_iterator(Ωₕ::AbstractMeshType)\n\nReturns an iterator for the spacing, for each submesh.\n\n\n\n\n\n","category":"method"},{"location":"internals/mesh/#Bramble.generate_indices-Tuple{PointsType} where PointsType","page":"Mesh","title":"Bramble.generate_indices","text":"generate_indices([::Dimension], pts)\n\nReturns the CartesianIndices of a mesh with pts[i] in each direction or just pts, if the argument is an Int.\n\n\n\n\n\n","category":"method"},{"location":"internals/mesh/#Bramble.half_point-Tuple{Bramble.AbstractMeshType, Any}","page":"Mesh","title":"Bramble.half_point","text":"half_point(Ωₕ::AbstractMeshType, idx)\n\nReturns a tuple with the half_points, for each submesh, of the points at index idx.\n\n\n\n\n\n","category":"method"},{"location":"internals/mesh/#Bramble.half_points-Tuple{Bramble.AbstractMeshType}","page":"Mesh","title":"Bramble.half_points","text":"half_points(Ωₕ::AbstractMeshType)\n\nReturns the half points, for each submesh.\n\n1D mesh (with idx=(i) or i)\n\nx_i+12 vcentcolon = x_i + frach_i+12  i=1dotsN-1\n\nx_N+12 vcentcolon = x_N   x_12 vcentcolon = x_1\n\n2D mesh, with idx = (ij)\n\n(x_i+12 y_j+12)\n\n3D mesh, with idx = (ijl)\n\n(x_i+12 y_j+12 z_l+12)\n\n\n\n\n\n","category":"method"},{"location":"internals/mesh/#Bramble.half_points_iterator-Tuple{Bramble.AbstractMeshType}","page":"Mesh","title":"Bramble.half_points_iterator","text":"half_points_iterator(Ωₕ::AbstractMeshType)\n\nReturns an iterator for the half_points, for each submesh.\n\n\n\n\n\n","category":"method"},{"location":"internals/mesh/#Bramble.half_spacing-Tuple{Bramble.AbstractMeshType, Any}","page":"Mesh","title":"Bramble.half_spacing","text":"half_spacing(Ωₕ::AbstractMeshType, idx)\n\nReturns a tuple with the half_spacings, for each submesh, at index idx.\n\n\n\n\n\n","category":"method"},{"location":"internals/mesh/#Bramble.half_spacings-Tuple{Bramble.AbstractMeshType}","page":"Mesh","title":"Bramble.half_spacings","text":"half_spacings(Ωₕ::AbstractMeshType)\n\nReturns the indexwise average of the space stepsize, for each submesh.\n\n1D mesh, with idx = (i) or i\n\nh_xi+12 vcentcolon = frach_xi + h_xi+12  i=1dotsN-1\n\nh_xN+12 vcentcolon = frach_N2 and h_x12 vcentcolon = frach_12\n\n2D mesh, with idx = (ij)\n\n(h_xi+12 h_yj+12)\n\n3D mesh, with idx = (ijl)\n\n(h_xi+12 h_yj+12 h_zl+12)\n\n\n\n\n\n","category":"method"},{"location":"internals/mesh/#Bramble.half_spacings_iterator-Tuple{Bramble.AbstractMeshType}","page":"Mesh","title":"Bramble.half_spacings_iterator","text":"half_spacings_iterator(Ωₕ::AbstractMeshType)\n\nReturns an iterator for the half_spacing, for each submesh.\n\n\n\n\n\n","category":"method"},{"location":"internals/mesh/#Bramble.index_in_marker-Tuple{Bramble.AbstractMeshType, Symbol}","page":"Mesh","title":"Bramble.index_in_marker","text":"index_in_marker(Ωₕ::AbstractMeshType, label::Symbol)\n\nReturns the BitVector associated with the marker with label of mesh Ωₕ.\n\n\n\n\n\n","category":"method"},{"location":"internals/mesh/#Bramble.indices-Tuple{Bramble.AbstractMeshType}","page":"Mesh","title":"Bramble.indices","text":"indices(Ωₕ::AbstractMeshType)\n\nReturns the CartesianIndices associated with the points of mesh Ωₕ. This function is a required part of the AbstractMeshType interface. Any concrete subtype of AbstractMeshType must implement this method and have a field called indices of type CartesianIndices.\n\n\n\n\n\n","category":"method"},{"location":"internals/mesh/#Bramble.interior_indices-Tuple{Bramble.AbstractMeshType}","page":"Mesh","title":"Bramble.interior_indices","text":"interior_indices(Ωₕ::AbstractMeshType)\n\nReturns a CartesianIndices object representing the interior region of the mesh Ωₕ.\n\n\n\n\n\n","category":"method"},{"location":"internals/mesh/#Bramble.interior_indices-Union{Tuple{CartesianIndices{D, R} where R<:NTuple{D, OrdinalRange{Int64, Int64}}}, Tuple{D}} where D","page":"Mesh","title":"Bramble.interior_indices","text":"interior_indices(indices::CartesianIndices)\n\nComputes the CartesianIndices representing the interior of a given domain, excluding all boundary points. This is achieved by shrinking the index range in each dimension by one from both ends. Dimensions with a length of one or less are returned unchanged.\n\nExamples\n\njulia> domain = CartesianIndices((3, 3)); interior_indices(domain)\nCartesianIndices((2:2, 2:2))\n\njulia> domain_2d_line = CartesianIndices((1, 5));\n\t   interior_indices(domain_2d_line)\nCartesianIndices((1:1, 2:4))\n\n\n\n\n\n","category":"method"},{"location":"internals/mesh/#Bramble.is_boundary_index-Tuple{Bramble.AbstractMeshType, Any}","page":"Mesh","title":"Bramble.is_boundary_index","text":"is_boundary_index(Ωₕ::AbstractMeshType, idx)\n\nChecks if the CartesianIndex idx lies on the boundary of the mesh Ωₕ. This delegates to the implementation for CartesianIndices.\n\n\n\n\n\n","category":"method"},{"location":"internals/mesh/#Bramble.is_boundary_index-Union{Tuple{D}, Tuple{CartesianIndices{D, R} where R<:NTuple{D, OrdinalRange{Int64, Int64}}, Any}} where D","page":"Mesh","title":"Bramble.is_boundary_index","text":"is_boundary_index(idxs::CartesianIndices, idx)\n\nChecks if a given index idx lies on the boundary of a CartesianIndices domain.\n\nExample\n\njulia> domain = CartesianIndices((3, 4));\n\t   is_boundary_index(domain, (1, 2));\ntrue\n\njulia> is_boundary_index(domain, (2, 2))\nfalse\n\n\n\n\n\n","category":"method"},{"location":"internals/mesh/#Bramble.point-Tuple{Bramble.AbstractMeshType, Any}","page":"Mesh","title":"Bramble.point","text":"point(Ωₕ::AbstractMeshType, idx)\n\nReturns the tuple with the point from the mesh corresponding to index idx. See points.\n\n\n\n\n\n","category":"method"},{"location":"internals/mesh/#Bramble.points_iterator-Tuple{Bramble.AbstractMeshType}","page":"Mesh","title":"Bramble.points_iterator","text":"points_iterator(Ωₕ::AbstractMeshType)\n\nReturns an iterator over the  points of Ωₕ.\n\n\n\n\n\n","category":"method"},{"location":"internals/mesh/#Bramble.set-Tuple{Bramble.AbstractMeshType}","page":"Mesh","title":"Bramble.set","text":"set(Ωₕ::AbstractMeshType)\n\nReturns the set of the domain over which the mesh Ωₕ is defined.\n\n\n\n\n\n","category":"method"},{"location":"internals/mesh/#Bramble.set_indices!-Tuple{Bramble.AbstractMeshType, Any}","page":"Mesh","title":"Bramble.set_indices!","text":"set_indices!(Ωₕ::AbstractMeshType, indices)\n\nOverrides the indices in Ωₕ.\n\n\n\n\n\n","category":"method"},{"location":"internals/mesh/#Bramble.spacing-Tuple{Bramble.AbstractMeshType, Any}","page":"Mesh","title":"Bramble.spacing","text":"spacing(Ωₕ::AbstractMeshType, idx)\n\nReturns a tuple with the spacing, for each submesh, at index idx.\n\n1D mesh, with idx = (i) or i\n\nh_xi vcentcolon = x_i - x_i-1  i=2dotsN\n\nand h_x1 vcentcolon = x_2 - x_1\n\n2D mesh, with idx = (ij)\n\n(h_xi h_yj) vcentcolon = (x_i - x_i-1 y_j - y_j-1)\n\n3D mesh, with idx = (ijl)\n\n(h_xi h_yj h_zl) vcentcolon = (x_i - x_i-1 y_j - y_j-1 z_l - z_l-1)\n\n\n\n\n\n","category":"method"},{"location":"internals/mesh/#Bramble.spacings_iterator-Tuple{Bramble.AbstractMeshType}","page":"Mesh","title":"Bramble.spacings_iterator","text":"spacings_iterator(Ωₕ::AbstractMeshType)\n\nReturns an iterator for the spacing, for each submesh.\n\n\n\n\n\n","category":"method"},{"location":"internals/mesh/#Bramble.MeshMarkers","page":"Mesh","title":"Bramble.MeshMarkers","text":"mutable struct Dict{Symbol, BitVector} <: AbstractDict{Symbol, BitVector}\n\nEfficient storage type for mesh markers as a Dict of Symbols. For each label, a BitVector is assigned that determines, for a given index, if the corresponding geometric point is identified by the marker.\n\n\n\n\n\n","category":"type"},{"location":"internals/mesh/#Bramble.__process_condition!-Tuple{Any, Any, Any}","page":"Mesh","title":"Bramble.__process_condition!","text":"__process_condition!(mesh_marker, identifier, Ωₕ)\n\nCore logic for evaluating a function-based (level-set) marker.\n\nIt iterates through every point in the mesh, evaluates the identifier function at that point's coordinates, and sets the marker to true if the function returns true.\n\n\n\n\n\n","category":"method"},{"location":"internals/mesh/#Bramble._init_mesh_markers-Tuple{Bramble.AbstractMeshType, Bramble.DomainMarkers}","page":"Mesh","title":"Bramble._init_mesh_markers","text":"_init_mesh_markers(Ωₕ, domain_markers)\n\nInternal helper function to create and initialize the MeshMarkers dictionary.\n\nThis function extracts all unique labels from the provided DomainMarkers object, which can come from symbol-, tuple-, or condition-based markers. It then prepares a MeshMarkers dictionary where each label is a key associated with a BitVector of falses, ready to be populated.\n\n\n\n\n\n","category":"method"},{"location":"internals/mesh/#Bramble._mark_indices!-Tuple{AbstractVector{Bool}, Any, CartesianIndex}","page":"Mesh","title":"Bramble._mark_indices!","text":"_mark_indices!(marker_set, linear_indices, indices_to_mark)\n\nA utility function to efficiently update a boolean marker vector.\n\nIt sets the value to true at the linear positions corresponding to the CartesianIndex or collection of CartesianIndices provided in indices_to_mark.\n\n\n\n\n\n","category":"method"},{"location":"internals/mesh/#Bramble._set_markers_conditions!-Tuple{Dict{Symbol, BitVector}, Any, Any}","page":"Mesh","title":"Bramble._set_markers_conditions!","text":"_set_markers_conditions!(mesh_markers, conditions, Ωₕ)\n\nIterates through all function-based markers and applies them to the mesh.\n\n\n\n\n\n","category":"method"},{"location":"internals/mesh/#Bramble._set_markers_symbols!-Tuple{Dict{Symbol, BitVector}, Any, Any}","page":"Mesh","title":"Bramble._set_markers_symbols!","text":"_set_markers_symbols!(mesh_markers, symbols, Ωₕ)\n\nProcesses markers that are identified by predefined symbols (e.g., :left, :top) or sets of those symbols.\n\n\n\n\n\n","category":"method"},{"location":"internals/mesh/#Bramble.boundary_symbol_to_cartesian-Tuple{CartesianIndices{1, R} where R<:Tuple{OrdinalRange{Int64, Int64}}}","page":"Mesh","title":"Bramble.boundary_symbol_to_cartesian","text":"boundary_symbol_to_cartesian(indices::CartesianIndices)\n\nMaps standard boundary symbols (:left, :right, :top, :bottom, :front, :back) to their corresponding CartesianIndices on the mesh boundary.\n\nReturns\n\nA NamedTuple with boundary symbols as keys and CartesianIndices as values:\n\n1D: :left, :right (single points)\n2D: :left, :right, :top, :bottom (faces)\n3D: All six faces of a rectangular prism\n\nExamples\n\njulia> boundary_symbol_to_cartesian(CartesianIndices((1:3, 1:4)))\n(left = CartesianIndices((1:1, 1:4)),\n right = CartesianIndices((3:3, 1:4)),\n top = CartesianIndices((1:3, 4:4)),\n bottom = CartesianIndices((1:3, 1:1)))\n\nSee also: boundary_symbol_to_dict, set_markers!\n\n\n\n\n\n","category":"method"},{"location":"internals/mesh/#Bramble.boundary_symbol_to_dict-Tuple{CartesianIndices}","page":"Mesh","title":"Bramble.boundary_symbol_to_dict","text":"boundary_symbol_to_dict(indices::CartesianIndices)\n\nReturns a dictionary connecting the facet labels of a set to the corresponding `CartesianIndices` (see [`boundary_symbol_to_cartesian`](@ref)).\n\n\n\n\n\n","category":"method"},{"location":"internals/mesh/#Bramble.process_label_for_mesh!-Tuple{Any, Dict{Symbol, BitVector}, Any}","page":"Mesh","title":"Bramble.process_label_for_mesh!","text":"process_label_for_mesh!(npts, markers_mesh, set_labels)\n\nInitializes boolean vectors for a given set of labels within the mesh markers dictionary.\n\nFor each label in set_labels, this function creates a BitVector of length npts (the total number of points in the mesh), initializes it with all false values, and assigns it to the corresponding key in the markers_mesh dictionary. This prepares the storage for later marking which points belong to which labeled region.\n\nArguments\n\nnpts: The total number of points in the mesh.\nmarkers_mesh: The MeshMarkers dictionary to be modified in-place.\nset_labels: An iterator or collection of Symbol labels to initialize.\n\n\n\n\n\n","category":"method"},{"location":"internals/mesh/#Bramble.set_markers!-Tuple{Bramble.AbstractMeshType, Any}","page":"Mesh","title":"Bramble.set_markers!","text":"set_markers!(Ωₕ::AbstractMeshType, domain_markers::DomainMarkers)\n\nApplies domain markers to mesh points, creating BitVector indicators for each label.\n\nThis function handles three types of markers:\n\nSymbol markers: Predefined boundary labels (:left, :right, etc.)\nTuple markers: Collections of boundary symbols\nFunction markers: Level-set conditions (including time-dependent functions)\n\nNotes\n\nTime-dependent markers are evaluated at the current time\nMarkers are stored as BitVectors in the mesh's markers field\nExisting markers are completely replaced\n\nExample\n\nΩ = domain(interval(0, 1) × interval(0, 1),\n\t\t   :inlet => :left,\n\t\t   :outlet => :right,\n\t\t   :walls => (:top, :bottom),\n\t\t   :obstacle => x -> norm(x .- 0.5) < 0.2)\nΩₕ = mesh(Ω, (20, 20), (true, true))\n# Ωₕ.markers now contains BitVectors for :inlet, :outlet, :walls, :obstacle\n\nSee also: DomainMarkers, MeshMarkers    # Initialize a dictionary to hold the boolean vectors for each marker label.\n\n\n\n\n\n","category":"method"},{"location":"internals/mesh/#Bramble.Mesh1D","page":"Mesh","title":"Bramble.Mesh1D","text":"mutable struct Mesh1D{BT<:Bramble.Backend, CI, VT<:(AbstractVector), T} <: Bramble.AbstractMeshType{1}\n\nA mutable structure representing a 1D mesh.\n\nThis struct holds all the geometric and topological information for a one-dimensional grid. It includes the coordinates of the grid points (pts), the underlying geometric interval (set), and a dictionary of markers for labeling specific points or regions. Key geometric quantities like cell centers (half_pts) and cell widths (half_spacings) are pre-computed and stored for efficiency, which is particularly useful in numerical methods like the finite volume method.\n\nThe struct is mutable to allow for in-place modifications, such as mesh refinement.\n\nFields\n\nset: the geometric domain, a 1D CartesianProduct (interval), over which the mesh is defined.\nmarkers: a dictionary mapping Symbol labels to BitVectors, marking specific points on the mesh.\nindices: the CartesianIndices of the grid, allowing for array-like iteration and indexing over the points.\nbackend: the computational backend used for linear algebra operations.\npts: a vector holding the coordinates of the grid points, x_i.\nhalf_pts: a vector of pre-computed cell centers (midpoints), x_i+12.\nhalf_spacings: a vector of pre-computed cell widths, h_i+12.\ncollapsed: a boolean flag indicating if the domain is degenerate (a single point).\n\nFor future reference, the entries of vector pts are\n\nx_i  i=1dotsN\n\n\n\n\n\n","category":"type"},{"location":"internals/mesh/#Base.show-Union{Tuple{T}, Tuple{VT}, Tuple{CI}, Tuple{BT}, Tuple{IO, Bramble.Mesh1D{BT, CI, VT, T}}} where {BT, CI, VT, T}","page":"Mesh","title":"Base.show","text":"Base.show(io::IO, Ωₕ::Mesh1D)\n\nCustom display for Mesh1D objects with detailed mesh information and colors.\n\n\n\n\n\n","category":"method"},{"location":"internals/mesh/#Bramble.half_points!-Tuple{Bramble.Mesh1D, Any}","page":"Mesh","title":"Bramble.half_points!","text":"half_points!(Ωₕ::Mesh1D, pts)\n\nOverrides the half_points in Ωₕ.\n\n\n\n\n\n","category":"method"},{"location":"internals/mesh/#Bramble.half_spacings!-Tuple{Bramble.Mesh1D, Any}","page":"Mesh","title":"Bramble.half_spacings!","text":"half_spacings!(Ωₕ::Mesh1D, pts)\n\nOverrides the spacings in Ωₕ.\n\n\n\n\n\n","category":"method"},{"location":"internals/mesh/#Bramble.set_points!-Tuple{Bramble.Mesh1D, Any}","page":"Mesh","title":"Bramble.set_points!","text":"set_points!(Ωₕ::Mesh1D, pts)\n\nOverrides the points in Ωₕ. This function recalculates the cached half_points and half_spacings.\n\n\n\n\n\n","category":"method"},{"location":"internals/mesh/#Bramble.MeshnD","page":"Mesh","title":"Bramble.MeshnD","text":"MeshnD{D,BT,CI,M1T,T}\n\nA structured D-dimensional tensor-product mesh (D ∈ {2,3}).\n\nThe mesh is constructed as a Cartesian product of 1D submeshes, enabling efficient storage and computation. Grid points are not explicitly stored; instead, they are accessed via the tensor product structure.\n\nType Parameters\n\nD: Spatial dimension (2 or 3)\nBT <: Backend: Linear algebra backend\nCI: CartesianIndices type\nM1T <: AbstractMeshType{1}: Type of 1D submeshes (typically Mesh1D)\nT: Element type (Float64, Float32, etc.)\n\nFields\n\nset: the D-dimensional CartesianProduct (hyperrectangle) defining the geometric domain.\nmarkers: a dictionary mapping Symbol labels to BitVectors, marking grid points.\nindices: the CartesianIndices for the full D-dimensional grid, allowing for multi-dimensional indexing.\nbackend: the computational backend used for linear algebra operations.\nsubmeshes: a tuple of D Mesh1D objects, representing the grid along each spatial dimension.\n\nExample\n\n# Create a 2D mesh with 20×30 grid points\nX = domain(interval(0, 1) × interval(0, 2))\nΩₕ = mesh(X, (20, 30), (true, false))\n\n# Access submeshes\nx_mesh = Ωₕ(1)  # 1D mesh in x-direction\ny_mesh = Ωₕ(2)  # 1D mesh in y-direction\n\n# Get a specific point\npoint(Ωₕ, (10, 15))  # Returns (x₁₀, y₁₅)\n\nSee also: Mesh1D, submeshes, mesh\n\n\n\n\n\n","category":"type"},{"location":"internals/mesh/#Bramble.MeshnD-Union{Tuple{Any}, Tuple{D}} where D","page":"Mesh","title":"Bramble.MeshnD","text":"(Ωₕ::MeshnD)(i)\n\nReturns the i-th submesh of Ωₕ.\n\n\n\n\n\n","category":"method"},{"location":"internals/mesh/#Base.show-Union{Tuple{T}, Tuple{M1T}, Tuple{CI}, Tuple{BT}, Tuple{D}, Tuple{IO, Bramble.MeshnD{D, BT, CI, M1T, T}}} where {D, BT, CI, M1T, T}","page":"Mesh","title":"Base.show","text":"Base.show(io::IO, Ωₕ::MeshnD)\n\nCustom display for MeshnD objects with detailed mesh information and colors.\n\n\n\n\n\n","category":"method"},{"location":"internals/mesh/#Bramble._mesh-Union{Tuple{D}, Tuple{Bramble.Domain, NTuple{D, Int64}, NTuple{D, Bool}, Any}} where D","page":"Mesh","title":"Bramble._mesh","text":"_mesh(Ω::Domain, npts, unif, backend)\n\nInternal constructor for a D-dimensional, tensor-product MeshnD.\n\nThis function orchestrates the creation of a structured multidimensional mesh. It first builds the underlying 1D submeshes for each dimension and then combines them into a single MeshnD object. It also handles the important edge case of \"collapsed\" dimensions (where an interval is just a point), forcing the number of grid points in that dimension to be 1.\n\nArguments\n\nΩ: The D-dimensional Domain to be meshed.\nnpts: An NTuple{D, Int} specifying the number of points in each dimension.\nunif: An NTuple{D, Bool} specifying if the grid is uniform in each dimension.\nbackend: The linear algebra backend.\n\n\n\n\n\n","category":"method"},{"location":"internals/mesh/#Bramble.submeshes-Tuple{Bramble.Domain, Any, Any, Any}","page":"Mesh","title":"Bramble.submeshes","text":"submeshes(Ω::Domain, npts, unif, backend)\n\nCreates the component 1D submeshes for a tensor-product grid.\n\nThis function takes a D-dimensional Domain and generates a tuple of D independent Mesh1D objects. Each submesh corresponds to one of the spatial dimensions of the original domain.\n\nArguments\n\nΩ: The D-dimensional Domain.\nnpts: A tuple containing the number of points for each dimension.\nunif: A tuple of booleans indicating if the grid is uniform in each dimension.\nbackend: The linear algebra backend.\n\n\n\n\n\n","category":"method"},{"location":"examples/poisson_nonlinear/#Nonlinear-Poisson-equation","page":"Nonlinear Poisson equation","title":"Nonlinear Poisson equation","text":"","category":"section"},{"location":"examples/poisson_nonlinear/","page":"Nonlinear Poisson equation","title":"Nonlinear Poisson equation","text":"In this section, we'll demonstrate how to utilize Bramble.jl to solve a nonlinear Poisson equation with Dirichlet boundary conditions.","category":"page"},{"location":"examples/poisson_nonlinear/","page":"Nonlinear Poisson equation","title":"Nonlinear Poisson equation","text":"","category":"page"},{"location":"examples/poisson_nonlinear/#Problem-description","page":"Nonlinear Poisson equation","title":"Problem description","text":"","category":"section"},{"location":"examples/poisson_nonlinear/","page":"Nonlinear Poisson equation","title":"Nonlinear Poisson equation","text":"Let's consider the following nonlinear Poisson equation on a 1-dimensional square domain Omega = 01,","category":"page"},{"location":"examples/poisson_nonlinear/","page":"Nonlinear Poisson equation","title":"Nonlinear Poisson equation","text":"beginalign*\n- fracpartialpartial x left( alpha(u) fracpartial upartial x (x) right) = f(x)  x in Omega \nu(x) = g(x)  x in partial Omega\nendalign*","category":"page"},{"location":"examples/poisson_nonlinear/","page":"Nonlinear Poisson equation","title":"Nonlinear Poisson equation","text":"We define","category":"page"},{"location":"examples/poisson_nonlinear/","page":"Nonlinear Poisson equation","title":"Nonlinear Poisson equation","text":"alpha (u) = 3 + frac1  1 + u^2","category":"page"},{"location":"examples/poisson_nonlinear/","page":"Nonlinear Poisson equation","title":"Nonlinear Poisson equation","text":"and","category":"page"},{"location":"examples/poisson_nonlinear/","page":"Nonlinear Poisson equation","title":"Nonlinear Poisson equation","text":"u(xy) = e^x + y  (xy) in 01^2","category":"page"},{"location":"examples/poisson_nonlinear/","page":"Nonlinear Poisson equation","title":"Nonlinear Poisson equation","text":"Function f and g are calculated such that u is the exact solution of the problem.","category":"page"},{"location":"examples/poisson_nonlinear/#Discretization","page":"Nonlinear Poisson equation","title":"Discretization","text":"","category":"section"},{"location":"examples/poisson_nonlinear/","page":"Nonlinear Poisson equation","title":"Nonlinear Poisson equation","text":"We refer to Linear Poisson equation for most of the notations used. To discretize the problem above, we just need to introduce an averaging operator on grid functions","category":"page"},{"location":"examples/poisson_nonlinear/","page":"Nonlinear Poisson equation","title":"Nonlinear Poisson equation","text":"M_h (u_h)(x_i) = fracu_h(x_i) + u_h(x_i-1)2","category":"page"},{"location":"examples/poisson_nonlinear/","page":"Nonlinear Poisson equation","title":"Nonlinear Poisson equation","text":"This allows to discretize the differential problem as the following variational problem","category":"page"},{"location":"examples/poisson_nonlinear/","page":"Nonlinear Poisson equation","title":"Nonlinear Poisson equation","text":"find u_h in W_h(overlineOmega_h), with u_h(x_i) = u(x_i) on partial overlineOmega_h, such that(alpha(u_h) D_-x u_h D_-x v_h)_+ = ((g)_h v_h)_h  forall v_h  in W_h0(overlineOmega_h)","category":"page"},{"location":"examples/poisson_nonlinear/#Implementation","page":"Nonlinear Poisson equation","title":"Implementation","text":"","category":"section"},{"location":"examples/poisson_nonlinear/","page":"Nonlinear Poisson equation","title":"Nonlinear Poisson equation","text":"To solve this nonlinear problem, we can use a standard fixed point iteration.","category":"page"},{"location":"examples/poisson_nonlinear/","page":"Nonlinear Poisson equation","title":"Nonlinear Poisson equation","text":"We start by loading the packages needed","category":"page"},{"location":"examples/poisson_nonlinear/","page":"Nonlinear Poisson equation","title":"Nonlinear Poisson equation","text":"using Bramble\nusing LinearSolve\nusing ILUZero      # for reusable sparsity pattern","category":"page"},{"location":"examples/poisson_nonlinear/","page":"Nonlinear Poisson equation","title":"Nonlinear Poisson equation","text":"and define the domain and relevant functions to the problem","category":"page"},{"location":"examples/poisson_nonlinear/","page":"Nonlinear Poisson equation","title":"Nonlinear Poisson equation","text":"I = interval(0, 1)\nΩ = domain(I)\n\nsol(x) = exp(x[1])\nα(u) = 3 + 1 / (1 + u[1]^2)\ndαdu(u) = -2 * u[1] / (1 + u[1]^2)^2\ng(x) = -d * dαdu(sol(x)) * sol(x)^2 - d * α(sol(x)) * sol(x)","category":"page"},{"location":"examples/poisson_nonlinear/","page":"Nonlinear Poisson equation","title":"Nonlinear Poisson equation","text":"Next, we define the mesh, the gridspace associated and dirichlet constraints objects","category":"page"},{"location":"examples/poisson_nonlinear/","page":"Nonlinear Poisson equation","title":"Nonlinear Poisson equation","text":"Ωₕ = mesh(Ω, (10, 20), (true, false))\nWₕ = gridspace(Ωₕ)\nbcs = dirichlet_constraints(X, :boundary => x -> sol(x))","category":"page"},{"location":"examples/poisson_nonlinear/","page":"Nonlinear Poisson equation","title":"Nonlinear Poisson equation","text":"Now we define an auxiliar element to store the approximate solution uₙ and calculate the right hand side u₀ using the average interpolator for our future linear system.","category":"page"},{"location":"examples/poisson_nonlinear/","page":"Nonlinear Poisson equation","title":"Nonlinear Poisson equation","text":"uₙ = element(Wₕ, 0)\n\nu₀ = similar(uₙ)\navgₕ!(u₀, rhs)","category":"page"},{"location":"examples/poisson_nonlinear/","page":"Nonlinear Poisson equation","title":"Nonlinear Poisson equation","text":"Next, we introduce the linear and bilinear forms associated with the problem. Here we use a u₀ vector which is due to the linearization of the nonlinear function we had before.","category":"page"},{"location":"examples/poisson_nonlinear/","page":"Nonlinear Poisson equation","title":"Nonlinear Poisson equation","text":"lₕ = form(Wₕ, vₕ -> innerₕ(u₀, vₕ))\nF = assemble(lₕ, bcs, dirichlet_labels = :boundary)\n\nαₕ(u) = (α.(M₋ₓ(u)) + α.(M₋ᵧ(u))) ./ 2\naₕ = form(Wₕ, Wₕ, (U, V) -> inner₊(αₕ(uₙ) * ∇₋ₕ(U), ∇₋ₕ(V)))\nA = assemble(aₕ, dirichlet_labels = :boundary)","category":"page"},{"location":"examples/poisson_nonlinear/","page":"Nonlinear Poisson equation","title":"Nonlinear Poisson equation","text":"We are aiming at calculating the fixed point of the solution of","category":"page"},{"location":"examples/poisson_nonlinear/","page":"Nonlinear Poisson equation","title":"Nonlinear Poisson equation","text":"(alpha_h(u_h) D_-x u_h D_-x v_h)_+ = (u_h v_h)_h  forall v_h  in W_h0(overlineOmega_h)","category":"page"},{"location":"examples/poisson_nonlinear/","page":"Nonlinear Poisson equation","title":"Nonlinear Poisson equation","text":"by using the iterative scheme: given u_h^(0), solve for n=1dots","category":"page"},{"location":"examples/poisson_nonlinear/","page":"Nonlinear Poisson equation","title":"Nonlinear Poisson equation","text":"left(alpha(u_h^(n)) D_-x u_h D_-x v_h right)_+ = (u_h v_h)_h","category":"page"},{"location":"examples/poisson_nonlinear/","page":"Nonlinear Poisson equation","title":"Nonlinear Poisson equation","text":"This is basically implemented in the following function","category":"page"},{"location":"examples/poisson_nonlinear/","page":"Nonlinear Poisson equation","title":"Nonlinear Poisson equation","text":"function fixed_point!(matrix, rhs, aₕ, uₚᵣₑᵥ, uₙₑₓₜ, coeff)\n\tprec = ilu0(matrix)\n\tprob = LinearProblem(matrix, rhs, KrylovJL_GMRES(), Pl = prec)\n\tlinsolve = init(prob)\n\n\tfor i in 1:2000\n\t\tuₚᵣₑᵥ .= coeff(uₙₑₓₜ)\n\t\tassemble!(matrix, aₕ, dirichlet_labels = :boundary)\n\n\t\tuₚᵣₑᵥ .= uₙₑₓₜ\n\t\tif i % 10 == 0\n\t\t\tilu0!(prec, matrix)\n\t\tend\n\n\t\tlinsolve.A = matrix\n\t\tsol = solve!(linsolve)\n\n\t\tuₙₑₓₜ .= sol\n\t\tuₚᵣₑᵥ .-= uₙₑₓₜ\n\n\t\tif norm₁ₕ(uₚᵣₑᵥ) < 1e-3\n\t\t\tbreak\n\t\tend\n\tend\nend","category":"page"},{"location":"examples/poisson_nonlinear/","page":"Nonlinear Poisson equation","title":"Nonlinear Poisson equation","text":"and we implemented a simple stopping criteria based on the norm₁ₕ of the difference between two consecutive iterations. Finally, we just need to call the fixed point function and we are done","category":"page"},{"location":"examples/poisson_nonlinear/","page":"Nonlinear Poisson equation","title":"Nonlinear Poisson equation","text":"fixed_point!(A, F, aₕ, u₀, uₙ, αₕ)","category":"page"},{"location":"examples/poisson_nonlinear/","page":"Nonlinear Poisson equation","title":"Nonlinear Poisson equation","text":"Vector uₙ has the approximate solution to u_h.","category":"page"},{"location":"#Bramble.jl","page":"Home","title":"Bramble.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This documentation is for Bramble.jl, a Julia library implementing discretization methods to solve partial differential equations using finite differences on nonuniform grids.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more information on the types of discretizations encompassed by Bramble.jl, please consult the papers","category":"page"},{"location":"","page":"Home","title":"Home","text":"J. A. Ferreira and R. D. Grigorieff, On the supraconvergence of elliptic finite difference schemes, Applied Numerical Mathematics 28 (1998), pp. 275-292\nS. Barbeiro, J. A. Ferreira and R. D. Grigorieff, Supraconvergence of a finite difference scheme for solutions in H^s(0L), IMA Journal of Numerical Analysis 25.4 (2005), pp. 797–811\nJ. A. Ferreira and R. D. Grigorieff, Supraconvergence and Supercloseness of a Scheme for Elliptic Equations on Nonuniform Grids, Numerical Functional Analysis and Optimization 27.5-6 (2006), pp. 539–564","category":"page"},{"location":"examples/poisson_linear/#Linear-Poisson-equation","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"","category":"section"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"In this section, we'll demonstrate how to utilize Bramble.jl to solve a linear Poisson equation with Dirichlet boundary conditions.","category":"page"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"","category":"page"},{"location":"examples/poisson_linear/#Problem-description","page":"Linear Poisson equation","title":"Problem description","text":"","category":"section"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"Let's consider the following Poisson equation on a n-dimensional square domain (n=123),","category":"page"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"beginalign*\n- Delta u (x) = f(x)  x in Omega \nu(x) = g(x)  x in partial Omega\nendalign*","category":"page"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"where Omega = (ab)^n.","category":"page"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"In order to have a working example of our Poisson problem we aim to solve, lets take n=2 and define","category":"page"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"u(xy) = e^x + y  (xy) in 01^2","category":"page"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"and calculate f and g accordingly.","category":"page"},{"location":"examples/poisson_linear/#Discretization","page":"Linear Poisson equation","title":"Discretization","text":"","category":"section"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"The former problem can be discretized with finite differences based on a nonuniform grid. We will now detail the mathematical tools needed to formalize our discretization method.","category":"page"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"Let us denote by Lambda a sequence of vectors h=(h_x_1 h_x_2), where h_x = (h_x1 h_x2 dots h_xN_x), h_y = (h_y1 h_y2 dots h_yN_y) and h_xj h_yj 0. Let us denote by h_max the maximum over all values of h_xj and h_yj.","category":"page"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"For each h in Lambda, we define the grid space","category":"page"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"overlineOmega_h = set(x_i y_j) in mathbbR^2 x_0 = y_0 = 0 x_i = x_i-1 + h_xi i=1dotsN_x  y_j = x_j-1 + h_yj j=1dotsN_y ","category":"page"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"We also denote by partial overlineOmega_h, the subset of grid points corresponding to the boundary partial Omega. Built upon these grids, we introduce the discrete spaces of grid functions","category":"page"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"W_h(overlineOmega_h) = setu_h overlineOmega_h longrightarrow mathbbR","category":"page"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"as well as W_h0(overlineOmega_h) subseteq W_h(overlineOmega_h), its subspace of functions that take zero values at the boundary.","category":"page"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"Finally, we introduce some notations for functions u_h and v_h in W_h(overlineOmega_h)","category":"page"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"(u_hv_h)_h = sum_i=1^N_xsum_j=1^N_y square_ij u_h(x_i y_j) v_h(x_iy_j)","category":"page"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"(u_hv_h)_+x = sum_i=1^N_xsum_j=1^N_y-1 h_xi h_yj+12 u_h(x_i y_j) v_h(x_iy_j)","category":"page"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"(u_hv_h)_+y = sum_i=1^N_x-1sum_j=1^N_y h_xi+12 h_yj u_h(x_i y_j) v_h(x_iy_j)","category":"page"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"where square_ij = leftx_i-frach_xi2 x_i+frach_xi+12 right times lefty_j-frach_yj2 y_j+frach_yj+12 right, square_ij is its area and h_cdoti+12 = frach_cdoti-h_cdoti+12.","category":"page"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"If D_-x and D_-y denote the standard backward difference operators defined on the grid points of overlineOmega_h, then, we can formulate the following discrete problem:","category":"page"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"find u_h in W_h(overlineOmega_h), with u_h(x_iy_j) = u(x_iy_j) on partial overlineOmega_h, such that(D_-xu_h D_-xv_h)_+x + (D_-yu_h D_-yu_h)_+y = ((g)_h v_h)_h  forall  v_h  in W_h0(overlineOmega_h)","category":"page"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"Here, the (cdot)_h operator is defined as follows","category":"page"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"(g)_h (x_iy_j) = frac1square_ij iint_square_ij g(x) dxdy","category":"page"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"This defines a discretization that can be seen both as a finite difference and finite element method. It can be shown that under certain smoothness assumptions on f and g, the former problem has a unique solution u_h such that","category":"page"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"Vert R_h u - u_h Vert_1h leq C h_max^ 2","category":"page"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"where","category":"page"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"Vert v_h Vert_1h = sqrtVert v_h Vert_h^2 + Vert D_-x v_h Vert_hx^2 + Vert D_y v_h Vert_hy^2","category":"page"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"and","category":"page"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"beginaligned\nVert v_h Vert_h = sqrt(v_hv_h)_h\n Vert D_-x v_h Vert_hx = sqrt(D_-x v_h D_-x v_h)_+x\n Vert D_-y v_h Vert_hy = sqrt(D_-y v_h D_-y v_h)_+y\n endaligned","category":"page"},{"location":"examples/poisson_linear/#Implementation","page":"Linear Poisson equation","title":"Implementation","text":"","category":"section"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"We can now use Bramble.jl to calculate u_h. As with any Julia package, we start by importing Bramble.jl and a few other packages we will need down the line","category":"page"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"using Bramble\nusing LinearSolve       # solvers for linear systems\nusing IncompleteLU: ilu # incomplete LU for preconditioning","category":"page"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"We start by building a grid associated with the Poisson equation's domain, as well as, the solution (to impose Dirichlet boundary conditions) and the equation's right hand side g.","category":"page"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"I = interval(0, 1)\nX = I × I\nΩ = domain(X)\nΩₕ = mesh(Ω, (10, 20), (true, false))","category":"page"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"The first three lines create a Domain object, while the third generates a mesh with 10 and 20 points along the x and y directions, respectively. The last input argument encodes that we want a uniform grid in the x axis and random generated points in the y axis.","category":"page"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"We now move on to define the Dirichlet constraints associated with that condition. We impose the expression of the exact solution to the whole domain boundary:","category":"page"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"bcs = dirichlet_constraints(set(Ω), :boundary => x -> sol(x))","category":"page"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"We now build the gridspace and define the linear and bilinear forms associated with the discrete variational problem presented. We create the discrete space with","category":"page"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"Wₕ = gridspace(Ωₕ)","category":"page"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"and move on to define the bilinear form and assembling the associated matrix","category":"page"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"aₕ = form(Wₕ, Wₕ, (Uₕ, Vₕ) -> inner₊(∇₋ₕ(Uₕ), ∇₋ₕ(Vₕ)))\nA = assemble(aₕ, dirichlet_labels = :boundary)","category":"page"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"In this case, we provide to the assemble function the information on boundary conditions in order to have this information encoded in matrix A.","category":"page"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"Next, we create an VectorElement in the gridspace whose components are calculated by the averaging operator avgₕ","category":"page"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"uₕ = element(Wₕ)\navgₕ!(uₕ, rhs)","category":"page"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"We now define the linear forms associated with the right hand side","category":"page"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"lₕ = form(Wₕ, vₕ -> innerₕ(uₕ, vₕ))\nF = assemble(lₕ, bcs, dirichlet_labels = :boundary)","category":"page"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"and assemble vector F. The solution of the linear system Ax=F will provide the components of vector uₕ, solution of the discrete variational problem. To solve the system, we use GMRES (package LinearSolve.jl) preconditioned with an incomplete LU factorization as precondition (package incompleteLU.jl)","category":"page"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"prec = ilu(A, τ = 0.001)\nprob = LinearProblem(A, F)\nsolₕ = solve(prob, KrylovJL_GMRES(), Pl = prec, verbose = false)\nuₕ .= solₕ.u","category":"page"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"and calculate the solution. If we want to calculate the error associated with this approximate solution (w.r.t norm₁ₕ), we can follow with","category":"page"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"F .= uₕ\nRₕ!(uₕ, sol)\nuₕ .-= F\n\nnorm₁ₕ(uₕ)","category":"page"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"We can even use GLMakie to plot the solution","category":"page"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"using GLMakie\n\nx = points(Ωₕ(1))\ny = points(Ωₕ(2))\n\nreshaped_uₕ = reshape(uₕ, 10, 20)\n\nfig = Figure(size = (1200, 800))\nax1 = Axis(fig[1, 1], aspect = 1)\nax2 = Axis3(fig[1, 2], aspect = (1, 1, 1),\n      perspectiveness = 0.5,\n      elevation = π / 3.5,\n      azimuth = 0.1π)\n\nwireframe!(ax1, x, y, reshaped_uₕ) # mesh plot\nsurface!(ax2, x, y, reshaped_uₕ)   # solution plot","category":"page"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"(Image: Mesh and approximate solution plots with GLMakie)","category":"page"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"or export it to a vtk format to visualize, for instance, with Paraview.","category":"page"},{"location":"examples/poisson_linear/","page":"Linear Poisson equation","title":"Linear Poisson equation","text":"export_file = \"surf\"\nvtk_grid(export_file, x, y, z) do vtk\n    vtk[\"poisson\"] = vis_uₕ\nend\n\nvtk_save(vtk)","category":"page"}]
}
